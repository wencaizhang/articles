[{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/%E5%89%8D%E7%AB%AF%E6%9E%9C%E9%85%B1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E5%89%8D%E7%AB%AF%E6%9E%9C%E9%85%B1/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"前端果酱","type":"authors"},{"authors":null,"categories":null,"content":"写给自己看的 JavaScript 参考手册 What is this 此文档为本人复习 JavaScript 基础知识时所整理，文档内容来自以下网站以及个人的理解：\n \rJavaScript · MDN \rECMAScript 6 入门 \rJavaScript 高级程序设计  除去学习每个 API 的使用之外，还尽量考虑「不用eval的前提下用JS实现一次JS」。\nContributing 所有内容均为手打，且为个人见解，难免存在各种各样的问题。\n如果您对本站点有一些疑惑，或发现了一些问题，或有什么建议，欢迎在 issue board 中讨论。如果发现有重大问题可发 Email 至 1052642137@qq.com\n地址 文档地址：\rhttp://coolfe.fun/oh-my-js/\n备用地址：\rhttps://wencaizhang.github.io/oh-my-js/\nEnd Just for fun! 😝\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1536451200,"objectID":"6e4b9df3395f0ebddc90a9dbdb2b8427","permalink":"/doc/oh-my-js/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/doc/oh-my-js/","section":"doc","summary":"JavaScript 中最基础最常用的内置函数总结","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"描述 Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。\n语法 Array.from(arrayLikeOrIterable[, mapFunction[, thisArg]]);\r  arrayLikeOrIterable: 第一个参数是类数组或者可迭代对象，为必传参数 mapFunction: 第二个参数是一个函数，会在集合中的每一项都调用，其返回值会插入到新的集合中（类似 map 函数的第二个参数），为可选参数。 thisArg: 调用 mapFunction 函数时的 this 指向，不常用，为可选参数。  示例 转化类数组(1) const arrayLike = {\r\u0026quot;0\u0026quot;: 10,\r\u0026quot;1\u0026quot;: 20,\r\u0026quot;2\u0026quot;: 30,\rlength: 3\r}\rArray.from(arrayLike, (value, index) =\u0026gt; value * 2);\r// [20, 40, 60]\r 转化类数组(2) let arrayLike = {\r\u0026quot;0\u0026quot;: \u0026quot;a\u0026quot;,\r\u0026quot;1\u0026quot;: \u0026quot;b\u0026quot;,\r\u0026quot;2\u0026quot;: \u0026quot;c\u0026quot;,\rlength: 3\r};\r// ES5的写法\rvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\r// ES6的写法\rlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\r 转化类数组(3) Array.from 会将字符串转化为数组\nlet str = 'foo'\rArray.from(str);\r// [\u0026quot;f\u0026quot;, \u0026quot;o\u0026quot;, \u0026quot;o\u0026quot;]\r 初始化数组 使用 Array.from 初始化默认每项元素的值是 undefined，而使用构造函数初始化默认元素值是 empty，在 map 等函数中会跳过 empty 元素，切记。\nArray.from({length: 3})\r// [undefined, undefined, undefined]\rArray(3)\r// [empty x 3]\rnew Array(3)\r// [empty x 3]\r 克隆数组 克隆数组的方法有很多，Array.from 就能很轻易地浅拷贝一个数组：\nconst nums = [ 1, 2, 3 ];\rconst nums2 = Array.from(nums);\rconsole.log(nums2); // [1, 2, 3]\rnums === nums2; // false\r 这就说明新数组 nums2 和原数组 nums 的元素一样，但是已经是两个不同的数组了。\n下面例子中 nums 和 nums2 的（引用类型的）元素是完全相同的，说明用 Array.from 是浅拷贝一个数组。\nconst nums = [\r[ 1, 2, 3 ],\r[ 'one', 'two', 'three' ]\r]\rconst nums2 = Array.from(nums)\rconsole.log(nums2);\rnums[0] === nums2[0] // true\rnums[1] === nums2[1] // true\r 下面做一个尝试，对只包含数组类型元素的数组进行深度克隆：\nfunction recursiveClone (arr) {\rreturn Array.isArray(arr) ? Array.from(arr, recursiveClone) : arr;\r}\rconst nums = [\r[ 1, 2, 3 ],\r[ 'one', 'two', 'three' ]\r]\rconst nums2 = recursiveClone(nums)\rnums[0] === nums2[0] // false\rnums[1] === nums2[1] // false\r 通过最后的判断可以看出深度克隆成就已经达成！\n这种深度克隆的方法非常简洁，但同时缺点也很明显，那就是这种方法只适合由基本类型和 Array 类型的元素组成的数组，因此使用这种方法之前需要确定自己克隆对象的类型。\n数组去重 function uniqArr (arr) {\rreturn Array.from(new Set(arr))\r}\runiqArr([ 1, 1, 2, 2, 4, 4]) // [1, 2, 4]\r 类似的数组去重方法还有：\nfunction uniqArr (arr) {\rreturn [...new Set(arr)]\r}\runiqArr([ 1, 1, 2, 2, 4, 4]) // [1, 2, 4]\r 填充数组 Array.from 函数可以使用相同的值来初始化一个数组\nconst length = 3\rconst init = 0\rconst arr = Array.from( { length }, () =\u0026gt; init )\rconsole.log(arr) // [0, 0, 0]\r  { length } 是 { length: length } 的简化写法\n 其实，Array.prototype.fill 函数也能达到「填充」的效果，而且从名字上看，Array.prototype.fill 才是官方指定的「填充」函数。\nfunction fillArray (init, length) {\rreturn Array(length).fill(init);\r}\rconst result = fillArray2(0, 3);\r// =\u0026gt; [0, 0, 0]\r 关于 Array.prototype.fill 的详细用法请移步\r这里\n生成数字范围数组 function range(end) {\rreturn Array.from({ length: end }, (item, index) =\u0026gt; index);\r}\rrange(4); // [0, 1, 2, 3]\r 参考文章  \r5 Handy Applications of JavaScript Array.from()  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"14dab8e6b850bdc6515001fd9467d0cf","permalink":"/doc/oh-my-js/03-array-es6/01-array.from/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/01-array.from/","section":"doc","summary":"描述 Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。\n语法 Array.from(arrayLikeOrIterable[, mapFunction[, thisArg]]);\r  arrayLikeOrIterable: 第一个参数是类数组或者可迭代对象，为必传参数 mapFunction: 第二个参数是一个函数，会在集合中的每一项都调用，其返回值会插入到新的集合中（类似 map 函数的第二个参数），为可选参数。 thisArg: 调用 mapFunction 函数时的 this 指向，不常用，为可选参数。  示例 转化类数组(1) const arrayLike = {\r\u0026quot;0\u0026quot;: 10,\r\u0026quot;1\u0026quot;: 20,\r\u0026quot;2\u0026quot;: 30,\rlength: 3\r}\rArray.","tags":null,"title":"Array.from()","type":"docs"},{"authors":null,"categories":null,"content":"描述 Array.isArray() 方法用于确定一个值是否为 Array 类型。\n注意：Array.isArray() 方法只能由构造函数 Array 调用，而数组实例无法调用。\nps：\r严格判断 JavaScript 对象是否为数组\n参数    参数 描述     value 需要检测的值    返回值 如果被检测的值是 Array 类型，返回 true ，否则返回 false 。\n示例 Array.isArray([]); // true\rArray.isArray([1]); // true\rArray.isArray(new Array()); // true\rArray.isArray(Array.prototype); // true\rArray.isArray(); // false\rArray.isArray({}); // false\rArray.isArray(null); // false\rArray.isArray(undefined); // false\rArray.isArray(12); // false\rArray.isArray(true); // false\r 模拟实现 Array.isArray = function(value) {\rreturn Object.prototype.toString.call(value) === \u0026quot;[Object Array]\u0026quot;;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"dccd0f9b7d569432ceaa9ec08fd6d966","permalink":"/doc/oh-my-js/03-array-es6/10-array.isarray/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/10-array.isarray/","section":"doc","summary":"描述 Array.isArray() 方法用于确定一个值是否为 Array 类型。\n注意：Array.isArray() 方法只能由构造函数 Array 调用，而数组实例无法调用。\nps：\r严格判断 JavaScript 对象是否为数组\n参数    参数 描述     value 需要检测的值    返回值 如果被检测的值是 Array 类型，返回 true ，否则返回 false 。","tags":null,"title":"Array.isArray()","type":"docs"},{"authors":null,"categories":null,"content":"描述 Array.of 方法用于将一组值转换为数组。基本可以用来替代 Array() 或者 new Array()，并且不存在由于参数不同而导致的重载。\n那么，使用构造函数来创建数组有什么问题呢？请看例子：\nconst arr1 = new Array(3);\rconst arr2 = new Array(3, 4);\rconst arr3 = new Array('a');\rconsole.log(arr1); // [empty x 3]\rconsole.log(arr2); // [3, 4]\rconsole.log(arr3); // [\u0026quot;a\u0026quot;]\r 可以总结一下：\n 如果只有一个参数，且参数为 Number 类型，则会得到一个所有元素都为“空”的数组，数组长度等于参数的值； 除了第一种情况之外，都会返回一个把参数当做元素的数组。  ps：第一种情况下得到的元素为“空”，这个空不是 null 或者 undefined，而是 empty。另外如果使用 forEach 和 map 等方法进行遍历，会跳过这些“空”元素。\nArray.of 方法相当于是第二种情况，永远都是将参数当做数组元素来处理。\n参数    参数 描述     arguments 任意值，不限个数。作为数组的元素。    返回值 返回由参数值组成的数组。如果没有参数，就返回一个空数组。\n示例 Array.of(); // []\rArray.of(undefined); // [ undefined ]\rArray.of(1); // [ 1 ]\rArray.of(1, 2); // [ 1, 2 ]\r 模拟实现 if (!Array.of) {\rfunction Array.of () {\rreturn [].slice.call(arguments);\r}\r}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"adbc8e405609ba0d553a016853cb7bda","permalink":"/doc/oh-my-js/03-array-es6/02-array.of/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/02-array.of/","section":"doc","summary":"描述 Array.of 方法用于将一组值转换为数组。基本可以用来替代 Array() 或者 new Array()，并且不存在由于参数不同而导致的重载。\n那么，使用构造函数来创建数组有什么问题呢？请看例子：\nconst arr1 = new Array(3);\rconst arr2 = new Array(3, 4);\rconst arr3 = new Array('a');\rconsole.log(arr1); // [empty x 3]\rconsole.log(arr2); // [3, 4]\rconsole.","tags":null,"title":"Array.of()","type":"docs"},{"authors":null,"categories":null,"content":"描述 copyWithin 方法接收三个参数：target、start 和 end，这三个参数都是整数。\ncopyWithin 方法会浅复制数组的一部分（从起始索引 start 开始，到结束索引 end 之前结束，不包含结束索引），然后将这部分元素移动到同一数组中的索引是 target 的位置，并返回它。因此这个方法会修改当前数组，但是长度不变。\n一句话总结：copyWithin 将数组的一部分元素移动到另一个位置。\n示例 var arr = [ 'a', 'b', 'c', 'd', 'e' ];\rarr.copyWithin(0, 3, 4);\rconsole.log(arr);\r// [\u0026quot;d\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;]\r// 被移动的元素，从索引 3 开始，到 4 之前结束（不包含）\r// 将指定的元素移动到索引 0 的位置\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"fcbc1d4434ff8863e94c7f7cc880ea72","permalink":"/doc/oh-my-js/03-array-es6/03-array.prototype.copywithin/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/03-array.prototype.copywithin/","section":"doc","summary":"描述 copyWithin 方法接收三个参数：target、start 和 end，这三个参数都是整数。\ncopyWithin 方法会浅复制数组的一部分（从起始索引 start 开始，到结束索引 end 之前结束，不包含结束索引），然后将这部分元素移动到同一数组中的索引是 target 的位置，并返回它。因此这个方法会修改当前数组，但是长度不变。\n一句话总结：copyWithin 将数组的一部分元素移动到另一个位置。\n示例 var arr = [ 'a', 'b', 'c', 'd', 'e' ];\rarr.copyWithin(0, 3, 4);\rconsole.log(arr);\r// [\u0026quot;d\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;]\r// 被移动的元素，从索引 3 开始，到 4 之前结束（不包含）\r// 将指定的元素移动到索引 0 的位置\r ","tags":null,"title":"Array.prototype.copyWithin()","type":"docs"},{"authors":null,"categories":null,"content":"描述 返回一个包含数组中每个索引的键值对的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.entries();\rresult.next();\r// {value: [0, \u0026quot;a\u0026quot;], done: false}\rresult.next();\r// {value: [1, \u0026quot;b\u0026quot;], done: false}\rresult.next();\r// {value: [2, \u0026quot;c\u0026quot;], done: false}\rresult.next();\r// {value: undefined, done: true}\rresult.next();\r// {value: undefined, done: true}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"abf39a89c18d8e873a18de38ccda1d58","permalink":"/doc/oh-my-js/03-array-es6/07-array.prototype.entries/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/07-array.prototype.entries/","section":"doc","summary":"描述 返回一个包含数组中每个索引的键值对的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.entries();\rresult.next();\r// {value: [0, \u0026quot;a\u0026quot;], done: false}\rresult.next();\r// {value: [1, \u0026quot;b\u0026quot;], done: false}\rresult.","tags":null,"title":"Array.prototype.entries()","type":"docs"},{"authors":null,"categories":null,"content":"描述 every() 方法对数组每一项运行给定函数 fn ，如果该函数对每一项都返回 true ，则 every() 方法返回 true，否则返回 false。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：\n 遍历的数组元素 对应的元素索引 数组本身  返回值 如果数组中每一项都使得给定函数 fn 返回 true，则 every() 方法返回 true ，否则返回 false 。\n示例 打印 fn 参数值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rarr.every(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r 如果 fn 返回 false ，则 every() 立即返回 false。 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rvar isEvery = arr.every(function(value, index, array) {\rconsole.log(value, index, array);\rreturn value === \u0026quot;b\u0026quot;;\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\rconsole.log(isEvery); // false\r 模拟实现 Array.prototype.every = function(fn, context) {\rvar arr = this;\rvar fn = fn;\rvar context = context;\rfor (var i = 0; i \u0026lt; arr.length; i++) {\rvar bool = fn.call(context, arr[i], i, arr);\rif (!bool) return false;\r}\rreturn true;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ae79740262c9e8df5a0deb65ca85ede2","permalink":"/doc/oh-my-js/02-array-es5/05-array.prototype.every/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/05-array.prototype.every/","section":"doc","summary":"描述 every() 方法对数组每一项运行给定函数 fn ，如果该函数对每一项都返回 true ，则 every() 方法返回 true，否则返回 false。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：","tags":null,"title":"Array.prototype.every()","type":"docs"},{"authors":null,"categories":null,"content":" 填充数组\n 描述 fill 方法用给定的值填充一个数组（将数组的每个元素都指向这个值）\n[1, 2, 3].fill(0);\r// [0, 0, 0]\r 另外还可以指定填充的起始位置和结束位置\n[1, 2, 3, 4, 5].fill(0, 0, 3);\r// [0, 0, 0, 4, 5]\r// 从索引 0 开始，到索引 3 之前结束\r 边界情况 如果缺少第三个参数，即没有指定填充的结束位置，默认是填充到数组最后一个元素 [1, 2, 3, 4, 5].fill(0, 2);\r// [1, 2, 0, 0, 0]\r// 从索引 2 开始到数组最后一个元素\r 后两个参数是负数 如果第二个参数是负数：\n[1, 2, 3].fill(0, -2);\r// [1, 0, 0]\r// -1 会被当成数组倒数第二个处理\r 相应的，如果第三个参数也是负数，也会这样处理\n[1, 2, 3, 4, 5].fill(0, -4, -1);\r// [1, 0, 0, 0, 5]\r// 从倒数第 4 个元素开始，到倒数第一个元素之前结束\r 第二个参数小于第三个参数 当第二个参数小于第三个参数的时候，fill 方法不做任何处理。\n[1, 2, 3, 4, 5].fill(0, 4, 2);\r// [1, 2, 3, 4, 5]\r[1, 2, 3, 4, 5].fill(0, -2, -4);\r// [1, 2, 3, 4, 5]\r 第二个参数不是数值 [1, 2, 3].fill(0, 'a');\r// [0, 0, 0]\r[1, 2, 3].fill(0, true);\r// [1, 0, 0]\r[1, 2, 3].fill(0, false);\r// [0, 0, 0]\r 可以看到 true 是一个比较特殊的值，在 fill 中会被当成 1 处理。\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"3258c34dcb2a270f64e83671c707dcaa","permalink":"/doc/oh-my-js/03-array-es6/06-array.prototype.fill/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/06-array.prototype.fill/","section":"doc","summary":"填充数组\n 描述 fill 方法用给定的值填充一个数组（将数组的每个元素都指向这个值）\n[1, 2, 3].fill(0);\r// [0, 0, 0]\r 另外还可以指定填充的起始位置和结束位置\n[1, 2, 3, 4, 5].fill(0, 0, 3);\r// [0, 0, 0, 4, 5]\r// 从索引 0 开始，到索引 3 之前结束\r 边界情况 如果缺少第三个参数，即没有指定填充的结束位置，默认是填充到数组最后一个元素 [1, 2, 3, 4, 5].","tags":null,"title":"Array.prototype.fill()","type":"docs"},{"authors":null,"categories":null,"content":" filter: 过滤\n 描述 filter() 方法对数组中每一项运行给定函数 fn ,返回使该函数返回值为 true 的项组成的数组。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：\n 遍历的数组元素 对应的元素索引 数组本身  返回值 过滤后的新数组，即令给定函数 fn 返回值为 true 的数组元素组成的新数组。\n示例 打印 fn 参数值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rarr.filter(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r fn 返回值如果不是布尔值，则会默认被转换成布尔值 var data = [0, 1, 2, 3];\rvar arrFilter = data.filter(function(item) {\rreturn item;\r});\rconsole.log(arrFilter); // [ 1, 2, 3 ]\r 模拟实现 Array.prototype.filter = function(fn, context) {\rvar arr = [];\rfor (var i = 0; i \u0026lt; this.length; i++) {\rvar bool = fn.call(context, this[i], i, this);\rif (bool) arr.push(this[i]);\r}\rreturn arr;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"fe12ccaa300b1c112a474c0dfaa23a3b","permalink":"/doc/oh-my-js/02-array-es5/03-array.prototype.filter/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/03-array.prototype.filter/","section":"doc","summary":"filter: 过滤\n 描述 filter() 方法对数组中每一项运行给定函数 fn ,返回使该函数返回值为 true 的项组成的数组。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：","tags":null,"title":"Array.prototype.filter()","type":"docs"},{"authors":null,"categories":null,"content":"描述 find 方法用于找出第一个符合条件的数组元素并返回，如果不存在就返回 undefined。\n类似 forEach 和 map，find 方法也接收两个参数：一个函数和函数参数执行时的上下文环境。\n不同之处在于，当函数参数返回值为 true 时，find 方法立即结束执行，不再继续遍历，并将使得函数参数返回值为 true 的元素作为 find 的返回值，这个元素就是“找到”的符合条件的元素。\n如果直到遍历结束时函数参数总也不返回 true，那么说明 find 的返回值为 undefined ，也就说明数组中不存在符合条件的元素。\n参数    参数 描述     callback 数组元素依次执行的回调函数   thisValue 指定 callback 执行的上下文环境，即 this 的值    示例 打印 callback 的参数 var arr = [ 'a', 'b', 'c' ];\rarr.find(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r find() 的返回值 有符合条件的，返回该数组元素，没有符合条件的，返回 undefined\nvar arr = [ 'a', 'b', 'c' ];\rvar result1 = arr.find(function(value, index, array) {\rreturn value == 'c'; });\rconsole.log(result1); // \u0026quot;c\u0026quot;\rvar result2 = arr.find(function(value, index, array) {\rreturn value == 'xyz'; });\rconsole.log(result2); // undefined\r 找到第一个符合条件的，方法立即结束执行 var arr = [ 'a', 'b', 'b', 'c' ];\rvar result1 = arr.find(function(value, index, array) {\rconsole.log(value);\rreturn value == 'b'; });\r// \u0026quot;a\u0026quot;\r// \u0026quot;b\u0026quot;\rconsole.log(result1); // \u0026quot;b\u0026quot;\r 指定 callback 执行时的 this 指向 var ages = [ 10, 12, 26, 15 ];\rvar person = {name: 'John', age: 20};\rvar age = ages.find(function (value) {\rreturn value \u0026gt; this.age;\r}, person);\rconsole.log(age); // 26\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"d5d1b700560fb521a103821f6d055f21","permalink":"/doc/oh-my-js/03-array-es6/04-array.prototype.find/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/04-array.prototype.find/","section":"doc","summary":"描述 find 方法用于找出第一个符合条件的数组元素并返回，如果不存在就返回 undefined。\n类似 forEach 和 map，find 方法也接收两个参数：一个函数和函数参数执行时的上下文环境。\n不同之处在于，当函数参数返回值为 true 时，find 方法立即结束执行，不再继续遍历，并将使得函数参数返回值为 true 的元素作为 find 的返回值，这个元素就是“找到”的符合条件的元素。\n如果直到遍历结束时函数参数总也不返回 true，那么说明 find 的返回值为 undefined ，也就说明数组中不存在符合条件的元素。\n参数    参数 描述     callback 数组元素依次执行的回调函数   thisValue 指定 callback 执行的上下文环境，即 this 的值    示例 打印 callback 的参数 var arr = [ 'a', 'b', 'c' ];\rarr.","tags":null,"title":"Array.prototype.find()","type":"docs"},{"authors":null,"categories":null,"content":"描述 findIndex 方法用于找出第一个符合条件的数组元素的索引。\n可参考 Array.prototype.find 方法，两者作用相同，都是找到符合条件的第一个数组元素，不同之处在于 find 方法返回元素值，而 findIndex 方法返回元素的索引\n示例 var arr = ['a', 'a', 'b', 'c'];\rvar item = arr.find(function (item) {\rreturn item === 'a';\r})\rvar index = arr.findIndex(function (item) {\rreturn item === 'a';\r})\rconsole.log(item); // \u0026quot;a\u0026quot;\rconsole.log(index); // 0\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"75577d81535e7aeb473959cefbcd0904","permalink":"/doc/oh-my-js/03-array-es6/05-array.prototype.findindex/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/05-array.prototype.findindex/","section":"doc","summary":"描述 findIndex 方法用于找出第一个符合条件的数组元素的索引。\n可参考 Array.prototype.find 方法，两者作用相同，都是找到符合条件的第一个数组元素，不同之处在于 find 方法返回元素值，而 findIndex 方法返回元素的索引\n示例 var arr = ['a', 'a', 'b', 'c'];\rvar item = arr.find(function (item) {\rreturn item === 'a';\r})\rvar index = arr.","tags":null,"title":"Array.prototype.findIndex()","type":"docs"},{"authors":null,"categories":null,"content":"描述 forEach() 方法对数组每一项运行给定函数 fn，无返回值。另外，还可以指定函数 fn 的上下文环境（this）。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数支持 3 个参数，依次是：\n 遍历的数组元素 对应的元素索引 数组本身  返回值 无\n示例 打印 fn 的参数 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rarr.forEach(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r 指定 fn 中 this 的值 var database = {\rusers: [\u0026quot;张含韵\u0026quot;, \u0026quot;江一燕\u0026quot;, \u0026quot;李小璐\u0026quot;],\rsendEmail: function(user) {\rif (this.isValidUser(user)) {\rconsole.log(\u0026quot;你好，\u0026quot; + user);\r} else {\rconsole.log(\u0026quot;抱歉，\u0026quot; + user + \u0026quot;，你不是本家人\u0026quot;);\r}\r},\risValidUser: function(user) {\rreturn /^张/.test(user);\r}\r};\r// 给每个人法邮件\rdatabase.users.forEach(\r// database.users 中人遍历\rdatabase.sendEmail, // 发送邮件\rdatabase // 使用 database 代替 sendEmail 的this\r);\r// 结果：\r// 你好，张含韵\r// 抱歉，江一燕，你不是本家人\r// 抱歉，李小璐，你不是本家\r forEach 不会遍历被删除的元素 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rdelete arr[1];\rconsole.log(arr); // [ \u0026quot;a\u0026quot;, , \u0026quot;c\u0026quot; ]\rconsole.log(arr.length); // 3\rarr.forEach(function(value, index) {\rconsole.log(value, index);\r});\r// a 0\r// c 2\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"4bc4f98ba4a3d7e31ca32f16b17d7cbf","permalink":"/doc/oh-my-js/02-array-es5/01-array.prototype.foreach/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/01-array.prototype.foreach/","section":"doc","summary":"描述 forEach() 方法对数组每一项运行给定函数 fn，无返回值。另外，还可以指定函数 fn 的上下文环境（this）。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数支持 3 个参数，依次是：","tags":null,"title":"Array.prototype.forEach()","type":"docs"},{"authors":null,"categories":null,"content":"描述 判断数组实例是否包含给定的值，返回一个布尔值。\n参数    参数 描述     value 必需。被检测的值   fromIndex Number 类型，可选。表示搜索的起始位置，默认为 0    示例 基本使用 const arr = [ 1, 2, 4 ];\rarr.includes(1); // true\rarr.includes(3); // false\r 指定 fromIndex const arr = [ 1, 2, 4 ];\rarr.includes(2, 2);\r// false\r// 从索引 2 开始检测，因此是 false\rarr.includes(2, 1);\r// true\r// 从索引 1 开始检测，结果是 true\r 边界值 NaN 的判断 首先我们知道 NaN 不等于 NaN：\nNaN == NaN // false\rNaN === NaN // false\r 而 indexOf 方法内部使用绝对相等（===）进行判断，因此无法判断 NaN，但是 includes 可以：\nconst arr = [ 1, NaN, 4 ];\rarr.indexOf(NaN); // -1\rarr.includes(NaN); // true\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"14289411fddd5d3a8013f8c3c4b2e467","permalink":"/doc/oh-my-js/03-array-es6/10-array.prototype.includes/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/10-array.prototype.includes/","section":"doc","summary":"描述 判断数组实例是否包含给定的值，返回一个布尔值。\n参数    参数 描述     value 必需。被检测的值   fromIndex Number 类型，可选。表示搜索的起始位置，默认为 0    示例 基本使用 const arr = [ 1, 2, 4 ];\rarr.","tags":null,"title":"Array.prototype.includes()","type":"docs"},{"authors":null,"categories":null,"content":"描述 indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引（使用全等操作符），如果不存在，则返回 -1 。\n参数    参数 描述     searchElement 要查找的元素   fromIndex 可选。开始查找的位置，如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从前向后查询数组）。如果抵消后的索引值仍小于 0 ，则整个数组都会被查询。默认值为 0 。    返回值 首个被找到的元素在数组中的索引，若没有找到则返回 -1 。\n示例 返回首个被查找到的元素的索引 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;a\u0026quot;];\rvar indexB = arr.indexOf(\u0026quot;b\u0026quot;);\rvar indexD = arr.indexOf(\u0026quot;d\u0026quot;);\rconsole.log(indexB); // 1\rconsole.log(indexD); // -1\r 严格相等 var arr = [1, 2, 3];\rvar indexStr = arr.indexOf(\u0026quot;2\u0026quot;);\rvar indexNum = arr.indexOf(2);\rconsole.log(indexStr); // -1\rconsole.log(indexNum); // 1\r 使用 fromeIndex 参数 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;];\rvar indexB1 = arr.indexOf(\u0026quot;b\u0026quot;);\rvar indexB2 = arr.indexOf(\u0026quot;b\u0026quot;, 2);\rconsole.log(indexB1); // 1\rconsole.log(indexB2); // 3\r fromIndex 大于或等于数组长度，返回 -1 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rvar index = arr.indexOf(\u0026quot;a\u0026quot;, 5);\rconsole.log(index); // -1\r fromIndex 为负值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\r// -1 表示从倒数第一个元素开始查找\rvar index = arr.indexOf(\u0026quot;a\u0026quot;, -1);\rconsole.log(index); // -1\r 模拟实现 Array.prototype.indexOf = function(searchElement, fromIndex) {\rvar se = searchElement;\rvar fi = parseInt(fromIndex) || 0;\rvar arr = this;\rvar len = arr.length;\rvar i = 0;\rif (fi \u0026gt;= len) return -1;\rif (fi \u0026lt; 0) {\ri = len + fi;\r}\rfor (; i \u0026lt; arr.length; i++) {\rif (arr[i] === se) {\rreturn i;\r}\r}\rreturn -1;\r};\r 拓展 indexOf 只能得到查找元素在数组中首次出现位置的索引，那如果我想要得到该元素在数组中所有出现位置的索引呢？\n下面是实现方法：\n/*\r* 返回查找元素在数组中所有的索引组成的数组，如果数组中不存在此元素，返回空数组。\r*/\rArray.prototype.allIndexOf = function(searchElement) {\rvar arr = this;\rvar se = searchElement;\rvar arrIndex = [];\rvar index = 0;\rfor (var i = 0; i \u0026lt; arr.length; i++) {\rindex = arr.indexOf(se, i);\rif (index === -1) {\rreturn [];\r}\rarrIndex.push(index);\ri = index;\r}\rreturn arrIndex;\r};\r  测试  var arr = [1, 2, 3, 2, 1];\rconsole.log(arr.allIndexOf(1)); // [0, 4]\rconsole.log(arr.allIndexOf(9)); // []\r// 嗯，确认过眼神，是我想要的！\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"b2a127e656a7470e4ff6369e079b3835","permalink":"/doc/oh-my-js/02-array-es5/06-array.prototype.indexof/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/06-array.prototype.indexof/","section":"doc","summary":"描述 indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引（使用全等操作符），如果不存在，则返回 -1 。\n参数    参数 描述     searchElement 要查找的元素   fromIndex 可选。开始查找的位置，如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从前向后查询数组）。如果抵消后的索引值仍小于 0 ，则整个数组都会被查询。默认值为 0 。    返回值 首个被找到的元素在数组中的索引，若没有找到则返回 -1 。","tags":null,"title":"Array.prototype.indexOf()","type":"docs"},{"authors":null,"categories":null,"content":"描述 返回一个包含数组中每个索引的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.keys();\rresult.next();\r// {value: 0, done: false}\rresult.next();\r// {value: 1, done: false}\rresult.next();\r// {value: 2, done: false}\rresult.next();\r// {value: undefined, done: true}\rresult.next();\r// {value: undefined, done: true}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ac190131e78fc69378ca0182ed6f04a9","permalink":"/doc/oh-my-js/03-array-es6/08-array.prototype.keys/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/08-array.prototype.keys/","section":"doc","summary":"描述 返回一个包含数组中每个索引的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.keys();\rresult.next();\r// {value: 0, done: false}\rresult.next();\r// {value: 1, done: false}\rresult.","tags":null,"title":"Array.prototype.keys()","type":"docs"},{"authors":null,"categories":null,"content":"描述 lastIndexOf() 方法返回在指定元素在数组中的最后一个的索引，如果不存在则返回 -1 。\n查找方式为从数组的后面向前查找，从 fromIndex 处开始（使用全等操作符）。\n参数    参数 描述     searchElement 要查找的元素   fromIndex 可选。开始查找的位置，在此位置开始从后向前查找。如果该值为负值且绝对值大于或等于数组长度，则返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从后向前查询数组）。默认值为数组长度减 1 ，即整个数组都被查找 。    返回值 首个被找到的元素在数组中的索引，若没有找到则返回 -1 。\n示例 返回首个被查找到的元素的索引 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;];\rvar indexB = arr.lastIndexOf(\u0026quot;b\u0026quot;);\rvar indexD = arr.lastIndexOf(\u0026quot;d\u0026quot;);\rconsole.log(indexB); // 3\rconsole.log(indexD); // -1\r 严格相等 var arr = [1, 2, 3];\rvar indexStr = arr.lastIndexOf(\u0026quot;2\u0026quot;);\rvar indexNum = arr.lastIndexOf(2);\rconsole.log(indexStr); // -1\rconsole.log(indexNum); // 1\r 使用 fromeIndex 参数 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;];\rvar indexB1 = arr.lastIndexOf(\u0026quot;b\u0026quot;);\rvar indexB2 = arr.lastIndexOf(\u0026quot;b\u0026quot;, 2);\rconsole.log(indexB1); // 3\rconsole.log(indexB2); // 1\r fromIndex 为负值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;];\rvar index1 = arr.lastIndexOf(\u0026quot;a\u0026quot;);\r// -2 表示从倒数第二个元素开始查找\rvar index2 = arr.lastIndexOf(\u0026quot;a\u0026quot;, -2);\rconsole.log(index1); // 4\rconsole.log(index2); // 0\r fromIndex 为负值且绝对值大于或等于数组长度，返回 -1 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rvar indexA = arr.lastIndexOf(\u0026quot;a\u0026quot;, 5);\rvar indexB = arr.lastIndexOf(\u0026quot;b\u0026quot;, -5);\rconsole.log(indexA); // 0\rconsole.log(indexB); // -1\r 模拟实现 Array.prototype.lastIndexOf = function(searchElement, fromIndex) {\rvar se = searchElement;\rvar arr = this;\rvar len = arr.length;\rvar fi = parseInt(fromIndex) || len - 1;\rvar i = fi;\rif (fi \u0026lt; 0 \u0026amp;\u0026amp; -fi \u0026gt;= len) return -1;\rif (fi \u0026lt; 0) {\ri = len + fi;\r}\rfor (; i \u0026gt;= 0; i--) {\rif (arr[i] === se) {\rreturn i;\r}\r}\rreturn -1;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"c3e57c393e8a4f938171a309b489a313","permalink":"/doc/oh-my-js/02-array-es5/07-array.prototype.lastindexof/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/07-array.prototype.lastindexof/","section":"doc","summary":"描述 lastIndexOf() 方法返回在指定元素在数组中的最后一个的索引，如果不存在则返回 -1 。\n查找方式为从数组的后面向前查找，从 fromIndex 处开始（使用全等操作符）。\n参数    参数 描述     searchElement 要查找的元素   fromIndex 可选。开始查找的位置，在此位置开始从后向前查找。如果该值为负值且绝对值大于或等于数组长度，则返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从后向前查询数组）。默认值为数组长度减 1 ，即整个数组都被查找 。    返回值 首个被找到的元素在数组中的索引，若没有找到则返回 -1 。","tags":null,"title":"Array.prototype.lastIndexOf()","type":"docs"},{"authors":null,"categories":null,"content":" map: 映射\n 描述 map() 方法对数组中每一项运行给定函数 callback ，返回值是每次 callback 函数调用的结果组成的数组。\n另外可以指定函数 callback 的上下文环境（this）。\n使用 map() 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。\n在 map() 方法执行过程中：\n 原数组新增加的元素将不会被 callback 访问到； 被删除的元素将不会被访问到。 若已经存在的元素被改变或删除了，则它们传递到 callback 的值是 map() 方法遍历到它们的那一时刻的值；  参数    参数 描述     callback function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    callback 函数支持 3 个参数，依次是：\n 遍历的数组元素 对应的元素索引 数组本身  返回值 返回给定函数 callback 调用的结果组成的数组。\n示例 打印 callback 参数值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rarr.map(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r callback 执行时的 this 值默认为 window (或 global) var arr = [1, 2, 3];\rthis.name = \u0026quot;name\u0026quot;;\rarr.map(function() {\rconsole.log(this.name);\r});\r// name\r// name\r// name\r callback 需要有 return 值，否则会被映射成 undefined var data = [1, 2, 3];\r// 无 return 值\rvar arrOfSquares = data.map(function(item) {});\rconsole.log(arrOfSquares); // [undefined, undefined, undefined]\r 求平方 var data = [1, 2, 3];\rvar arrOfSquares = data.map(function(item) {\rreturn item * item;\r});\rconsole.log(arrOfSquares); // [ 1, 4, 9 ]\r 获取对象数组中的特定属性值 var users = [\r{ name: \u0026quot;张三\u0026quot;, age: 18 },\r{ name: \u0026quot;李四\u0026quot;, age: 19 },\r{ name: \u0026quot;王五\u0026quot;, age: 21 }\r];\rvar names = users.map(function(user) {\rreturn user.name;\r});\rconsole.log(names.join(\u0026quot;，\u0026quot;)); // 张三，李四，王五\r 模拟实现 if (typeof Array.prototype.map != \u0026quot;function\u0026quot;) {\rArray.prototype.map = function(fn, context) {\rvar arr = [];\rif (typeof fn === \u0026quot;function\u0026quot;) {\rfor (var i = 0, len = this.length; i \u0026lt; len; k++) {\rarr.push(fn.call(context, this[i], k, this));\r}\r}\rreturn arr\r};\r}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"d5d81a0003ca7ded71d627c966a9e97a","permalink":"/doc/oh-my-js/02-array-es5/02-array.prototype.map/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/02-array.prototype.map/","section":"doc","summary":"map: 映射\n 描述 map() 方法对数组中每一项运行给定函数 callback ，返回值是每次 callback 函数调用的结果组成的数组。\n另外可以指定函数 callback 的上下文环境（this）。\n使用 map() 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。\n在 map() 方法执行过程中：\n 原数组新增加的元素将不会被 callback 访问到； 被删除的元素将不会被访问到。 若已经存在的元素被改变或删除了，则它们传递到 callback 的值是 map() 方法遍历到它们的那一时刻的值；  参数    参数 描述     callback function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    callback 函数支持 3 个参数，依次是：","tags":null,"title":"Array.prototype.map()","type":"docs"},{"authors":null,"categories":null,"content":" reduce: 减少，缩小。但是 reduce() 方法并无此含义，而是“迭代，递归”。\n 描述 reduce() 方法从左向右迭代数组所有项，构建一个最终返回的值。\nreduce() 方法接收两个参数：一个在每一项上调用的函数和（可选）作为迭代基础的初始值。\n参数    参数 描述     fn 迭代时执行的函数   initialValue 可选。当做初次调用 fn 的第一个参数值。    fn 有 4 个参数：\n 之前值，initialValue 。若缺省 initialValue ，则使用数组第一个元素作为初始值。 当前值，若指定 initialValue ，当前值为数组第一个元素，否则使用数组第二个元素。 索引值，当前值的索引 调用 reduce() 的数组  返回值 数组迭代执行 fn 完毕，最后一次执行 fn 的返回值。\n示例 不指定 initialValue var nums = [0, 1, 2, 3, 4];\rvar sum = nums.reduce(function(previous, current, index, array) {\rconsole.log(previous, current, index, array, previous + current);\rreturn previous + current;\r});\rconsole.log(sum); // 10\r 函数 fn 被执行 4 次， 每次的参数和返回值如下：\n   previous current index array 返回值     第一次 0 1 1 [0, 1, 2, 3, 4]   第二次 1 2 2 [0, 1, 2, 3, 4]   第三次 3 3 3 [0, 1, 2, 3, 4]   第四次 6 4 4 [0, 1, 2, 3, 4]    指定 initialValue var nums = [0, 1, 2, 3, 4];\rvar sum = nums.reduce(function(previous, current, index, array) {\rconsole.log(previous, current, index, array, previous + current);\rreturn previous + current;\r}, 100);\rconsole.log(sum); // 110\r 函数 fn 被执行 5 次， 每次的参数和返回值如下：\n   previous current index array 返回值     第一次 100 0 0 [0, 1, 2, 3, 4]   第二次 100 1 1 [0, 1, 2, 3, 4]   第三次 101 2 2 [0, 1, 2, 3, 4]   第四次 103 3 3 [0, 1, 2, 3, 4]   第五次 106 4 4 [0, 1, 2, 3, 4]    模拟实现 // TODO\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"b557ad802e045c9a9f7d428762d37bc5","permalink":"/doc/oh-my-js/02-array-es5/08-array.prototype.reduce/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/08-array.prototype.reduce/","section":"doc","summary":"reduce: 减少，缩小。但是 reduce() 方法并无此含义，而是“迭代，递归”。\n 描述 reduce() 方法从左向右迭代数组所有项，构建一个最终返回的值。\nreduce() 方法接收两个参数：一个在每一项上调用的函数和（可选）作为迭代基础的初始值。\n参数    参数 描述     fn 迭代时执行的函数   initialValue 可选。当做初次调用 fn 的第一个参数值。    fn 有 4 个参数：","tags":null,"title":"Array.prototype.reduce()","type":"docs"},{"authors":null,"categories":null,"content":"描述 reduceRight() 方法可参考 reduce 方法，除迭代方向不同之外，其他功能和 reduce 保持一致。\nreduceRight 是从右向左迭代数组所有项，而 reduce 是从左向右。\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"61558e5b1e4754639e1e337a32d25d58","permalink":"/doc/oh-my-js/02-array-es5/09-array.prototype.reduceright/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/09-array.prototype.reduceright/","section":"doc","summary":"描述 reduceRight() 方法可参考 reduce 方法，除迭代方向不同之外，其他功能和 reduce 保持一致。\nreduceRight 是从右向左迭代数组所有项，而 reduce 是从左向右。","tags":null,"title":"Array.prototype.reduceRight()","type":"docs"},{"authors":null,"categories":null,"content":"描述 some() 方法对数组每一项运行给定函数 fn ，如果该函数对任意一项返回 true ，则 some() 方法返回 true，否则返回 false。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：\n 遍历的数组元素 对应的元素索引 数组本身  返回值 如果数组中存在使得给定函数 fn 返回 true 的元素，返回 true ，否则返回 false 。\n示例 打印 fn 参数值 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rarr.some(function(value, index, array) {\rconsole.log(value, index, array);\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// c 2 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r 如果 fn 返回 true ，则 some() 立即返回 true。 var arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rvar some = arr.some(function(value, index, array) {\rconsole.log(value, index, array);\rreturn value === \u0026quot;b\u0026quot;;\r});\r// a 0 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\r// b 1 [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\rconsole.log(some); // true\r fn 返回值如果不是布尔值，则会默认被转换成布尔值 var data = [0, 1, 2, 3];\rvar some = data.some(function(item) {\rconsole.log(item);\rreturn item;\r});\r// 0\r// 1\rconsole.log(some); // true\r 模拟实现 Array.prototype.some = function(fn, context) {\rvar arr = this;\rvar fn = fn;\rvar context = context;\rfor (var i = 0; i \u0026lt; arr.length; i++) {\rvar bool = fn.call(context, arr[i], i, arr);\rif (!!bool) return true;\r}\rreturn false;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"943a272f29c1b0836998cb6c1a30f582","permalink":"/doc/oh-my-js/02-array-es5/04-array.prototype.some/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/04-array.prototype.some/","section":"doc","summary":"描述 some() 方法对数组每一项运行给定函数 fn ，如果该函数对任意一项返回 true ，则 some() 方法返回 true，否则返回 false。\n参数    参数 描述     fn function 类型，必需。数组中每个元素需要调用的函数   context 可选。执行回调时的上下文（this）    fn 函数有三个参数，依次是：","tags":null,"title":"Array.prototype.some()","type":"docs"},{"authors":null,"categories":null,"content":"描述 返回一个包含数组中每个索引对应的值的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.values();\rresult.next();\r// {value: \u0026quot;a\u0026quot;, done: false}\rresult.next();\r// {value: \u0026quot;b\u0026quot;, done: false}\rresult.next();\r// {value: \u0026quot;c\u0026quot;, done: false}\rresult.next();\r// {value: undefined, done: true}\rresult.next();\r// {value: undefined, done: true}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"7e83e6323cd654285880b9fbb2295fb5","permalink":"/doc/oh-my-js/03-array-es6/09-array.prototype.values/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/09-array.prototype.values/","section":"doc","summary":"描述 返回一个包含数组中每个索引对应的值的 Array Iterator 对象。\n示例 var arr = [ 'a', 'b', 'c' ];\rvar result = arr.values();\rresult.next();\r// {value: \u0026quot;a\u0026quot;, done: false}\rresult.next();\r// {value: \u0026quot;b\u0026quot;, done: false}\rresult.","tags":null,"title":"Array.prototype.values()","type":"docs"},{"authors":null,"categories":null,"content":"   名称 含义 是否修改原数组     \rconcat 合并数组 不修改   \rjoin 指定一个分隔符，将数组元素拼接成字符串 不修改   \rpush 将一个元素添加到数组末尾 修改   \rpop 删除数组最后一项 修改   \rshift 删除数组第一项 修改   \runshift 将一个元素添加到数组开头 修改   \rslice 切割数组 不修改   \rsplice 在指定位置增加或删除一个或多个元素 修改   \rreverse 反转数组顺序 修改   \rsort 对数组排序，可以指定排序规则 修改    ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"443224bb42c795b7c4e1e934ee446886","permalink":"/doc/oh-my-js/01-array-es3/00-readme/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/00-readme/","section":"doc","summary":"   名称 含义 是否修改原数组     \rconcat 合并数组 不修改   \rjoin 指定一个分隔符，将数组元素拼接成字符串 不修改   \rpush 将一个元素添加到数组末尾 修改   \rpop 删除数组最后一项 修改   \rshift 删除数组第一项 修改   \runshift 将一个元素添加到数组开头 修改   \rslice 切割数组 不修改   \rsplice 在指定位置增加或删除一个或多个元素 修改   \rreverse 反转数组顺序 修改   \rsort 对数组排序，可以指定排序规则 修改    ","tags":null,"title":"ES3 数组方法总览","type":"docs"},{"authors":null,"categories":null,"content":"ES5 新增数组方法总览 ES5 新增了一些数组方法，灵活运用这些方法可以让我们少些很多代码，而且可以在一定程度上替代 underscore/lodash 等工具库。\n \rforEach: 遍历数组一个数组 \rmap: 将数组映射为一个新数组 \rfilter: 过滤数组，找出符合某种条件的元素，将其组合成新数组 \rsome: 判断是否一个或多个的数组元素符合某种条件的 \revery: 判断是否所有的数组元素都符合某种条件 \rindexOf: 得到一个值在数组中首次出现的索引 \rlastIndexOf: 得到一个值在数组中最后一次出现的索引 \rreduce: 对一个数组进行迭代递归操作 \rreduceRight: 作用同 reduce，但是是从数组最后一项向第一项进行遍历  其中有一部分方法有一些相同之处：相同的参数。\n第一个参数是一个函数，第二个参数是第一个参数函数执行时的上下文环境，即 this 指向，第二个参数非必需。\n而且第一个参数函数有三个参数：数组元素、元素索引和数组本身。\n注意  这些方法遍历时会跳过值为空的元素。  这里的“值为空”不是指 null 或 undefined，而是使用构造函数创建且未指定元素值的数组元素。\nvar arr = new Array(3);\rconsole.log(arr);\r 在遍历过程中删除元素，回导致遍历提前结束  第一段代码：分别打印：1，2，3，4，5\nvar arr = [1, 2, 3, 4, 5]\rarr.forEach(function (item, index) {\rconsole.log(item)\r})\r 第二段代码：分别打印：1，2，4，5\nvar arr = [1, 2, 3, 4, 5]\rarr.forEach(function (item, index) {\rconsole.log(item)\rif (index === 1) {\rarr.splice(index, 1);\r}\r})\r 第三段代码：也是分别打印：1，2，4，5\nvar arr = [1, 2, 3, 4, 5]\rarr.forEach(function (item, index) {\rconsole.log(item)\rif (index === 1) {\rarr.splice(0, 1);\r}\r})\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"6bc299ad031cad23e0010637147d26e9","permalink":"/doc/oh-my-js/02-array-es5/readme/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/02-array-es5/readme/","section":"doc","summary":"ES5 新增数组方法总览 ES5 新增了一些数组方法，灵活运用这些方法可以让我们少些很多代码，而且可以在一定程度上替代 underscore/lodash 等工具库。\n \rforEach: 遍历数组一个数组 \rmap: 将数组映射为一个新数组 \rfilter: 过滤数组，找出符合某种条件的元素，将其组合成新数组 \rsome: 判断是否一个或多个的数组元素符合某种条件的 \revery: 判断是否所有的数组元素都符合某种条件 \rindexOf: 得到一个值在数组中首次出现的索引 \rlastIndexOf: 得到一个值在数组中最后一次出现的索引 \rreduce: 对一个数组进行迭代递归操作 \rreduceRight: 作用同 reduce，但是是从数组最后一项向第一项进行遍历  其中有一部分方法有一些相同之处：相同的参数。","tags":null,"title":"ES5 新增数组方法总览","type":"docs"},{"authors":null,"categories":null,"content":"ES6 新增数组方法总览  \risArray: 判断一个值是否是 Array 类型  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"d5f56ee71cbd207e3e46999b089bc4d2","permalink":"/doc/oh-my-js/03-array-es6/readme/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/03-array-es6/readme/","section":"doc","summary":"ES6 新增数组方法总览  \risArray: 判断一个值是否是 Array 类型  ","tags":null,"title":"ES6 新增数组方法总览","type":"docs"},{"authors":null,"categories":null,"content":"描述 ES6 引入 Object.assign 方法，它用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n参数 第一个参数是目标对象，后面的参数都是源对象。\n返回值 合并之后的目标对象。\n示例 0. 基本使用 const target = { a: 1 };\rconst source1 = { a: 2, b: 2, c: 2 };\rconst source2 = { b: 3, c: 3, d: 3 };\rObject.assign(target, source1, source2);\rconsole.log(target); // {a: 2, b: 3, c: 3, d: 3}\r// 可以看到对于同名属性的处理是，后面的\r 1. 同名属性后面覆盖前面 const target = { a: 1, b: 1 };\rconst source1 = { b: 2 , c: 2 };\rconst source2 = { c: 3 };\rObject.assign(target, source1, source2);\rconsole.log(target); // {a: 1, b: 2, c: 3}\r 2. 只有一个参数 只有一个参数，直接返回该参数\nconst obj = { a: 1 };\rObject.assign(obj) === obj; // true\r 如果该参数不是对象，则会先转成对象，然后返回。\ntypeof Object.assign(2); // \u0026quot;object\u0026quot;\r 参数是 undefined 或 null，会报错。\nObject.assign(undefined); // 报错\rObject.assign(null); // 报错\r 3. 源对象不是 Object 类型 如果源对象不是 Object 类型，会先将其转换为对象，如果无法转换，则跳过。\n因此，undefined 和 null 不会报错，数字和布尔值也不会报错，会直接跳过，无任何效果。\n而字符串会以数组形式拷贝到目标对象。\nObject.assign({}, undefined); // {}\rObject.assign({}, null); // {}\rObject.assign({}, 1); // {}\rObject.assign({}, true); // {}\rObject.assign({}, 'abcd'); // {0: \u0026quot;a\u0026quot;, 1: \u0026quot;b\u0026quot;, 2: \u0026quot;c\u0026quot;, 3: \u0026quot;d\u0026quot;}\rObject.assign({}, { a: 1 }); // { a: 1 }\r 4. assign() 是浅拷贝 如果源对象的某个属性值是对象，那么目标对象拷贝得到的是这个对象的引用。\n此属性发生任何变化，都会反映到目标对象上。\nconst obj = { person: { name: 'jack' } };\rconst obj2 = Object.assign({}, obj);\robj.person.name = 'tom';\rconsole.log(obj2.person.name); // \u0026quot;tom\u0026quot;\r 5. 数组的处理 Object.assign 可以用来处理数组，但是会把数组视为对象。\nObject.assign([1, 2, 3], [4, 5]); // [4, 5, 3]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"d4b8c1c43e7d02f637ba7e3e9df8c0fa","permalink":"/doc/oh-my-js/05-object/05-object.assign/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/05-object.assign/","section":"doc","summary":"描述 ES6 引入 Object.assign 方法，它用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n参数 第一个参数是目标对象，后面的参数都是源对象。\n返回值 合并之后的目标对象。\n示例 0. 基本使用 const target = { a: 1 };\rconst source1 = { a: 2, b: 2, c: 2 };\rconst source2 = { b: 3, c: 3, d: 3 };\rObject.","tags":null,"title":"Object.assign()","type":"docs"},{"authors":null,"categories":null,"content":"描述 Object.create() 方法用于创建一个新对象，并且将新对象的 __proto__ 指向一个现有的对象。\nObject.create() 接收两个参数，第一个参数就是新对象的原型对象，第二个参数（可选）是一个用于向新建对象自身添加属性的对象，对象的格式对应 Object.defineProperty() 的第二个参数。\nObject.create() 返回值是新创建的已经指定了原型和属性的对象。\n::: danger 注意 第二个参数可以不传，但不能为 null 或者非原始包装对象，否则会抛出 TypeError 异常。 :::\n例子 利用 Object.create() 实现继承 关于原型，我们应该知道函数具有一个 prototype 属性，这个属性值是一个对象，它默认有一个 constructor 属性，指向这个函数本身，因此需要在子类继承父类之后，将子类 prototype.constructor 指向子类本身。\nvar Person = function () {\rthis.sex = 'all'\r}\rPerson.prototype = {\reat: function () { console.log('eat!') }\r};\rvar Man = function () {\r// 继承 Person 构造函数内部（非prototype）的属性\rPerson.call(this)\rthis.sex = 'man'\r}\r// 子类继承父类\rMan.prototype = Object.create(Person.prototype)\r// 修正 constructor 指向\rMan.prototype.constructor = Man\r 可以通过打印来验证我们的想法：\nconsole.log(Man.prototype === Person.prototype) // false\rconsole.log(Man.prototype.__proto__ === Person.prototype) // true\rconsole.log(Man.prototype.constructor === Man)\rvar p1 = new Person()\rvar m1 = new Man()\rconsole.log(m1.eat === p1.eat) // true\rPerson.prototype.play = function () {\rconsole.log('play')\r}\rp1.play() // play\rm1.play() // play\r 继承多个对象 参考链接 \r包装对象\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"b1a63c88f3b0d565ebe0c3efe4d658f8","permalink":"/doc/oh-my-js/05-object/08-object.create/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/08-object.create/","section":"doc","summary":"描述 Object.create() 方法用于创建一个新对象，并且将新对象的 __proto__ 指向一个现有的对象。\nObject.create() 接收两个参数，第一个参数就是新对象的原型对象，第二个参数（可选）是一个用于向新建对象自身添加属性的对象，对象的格式对应 Object.defineProperty() 的第二个参数。\nObject.create() 返回值是新创建的已经指定了原型和属性的对象。\n::: danger 注意 第二个参数可以不传，但不能为 null 或者非原始包装对象，否则会抛出 TypeError 异常。 :::\n例子 利用 Object.create() 实现继承 关于原型，我们应该知道函数具有一个 prototype 属性，这个属性值是一个对象，它默认有一个 constructor 属性，指向这个函数本身，因此需要在子类继承父类之后，将子类 prototype.constructor 指向子类本身。","tags":null,"title":"Object.create()","type":"docs"},{"authors":null,"categories":null,"content":"::: tip Vue.js@2.x 的响应式系统就是利用 Object.defineProperty 实现的，参考 深入响应式原理 :::\n用法 这个方法在一个对象上定义一个新属性，或者修改一个已经存在的属性。并返回这个对象。\nObject.defineProperty(obj, prop, descriptor);\r  obj: 目标对象 prop: 要操作的属性 descriptor: 用于指定对象属性的特性，这些特性包括：  value: 属性的值，默认为 undefined writable: 属性的值是否可以被重写，默认为 true get: 获取属性值的时候触发的函数，默认为 undefined set: 设置属性值的时候触发的函数，默认为 undefined configurable: 是否可以删除目标属性或是否可以再次修改属性的特性，默认为 true enumerable: 此属性是否可以被枚举（使用for\u0026hellip;in或Object.keys()），默认为 true    示例 修改属性的 value var obj = { name: 'jack', age: 18 };\rObject.defineProperty( obj, 'age', {\rvalue: 22\r});\rconsole.log( obj.age ); // 22\r// age 属性已经被修改\r 如果对象不存在这个属性，就会创建这个属性\nvar obj = { name: 'jack' };\rObject.defineProperty( obj, 'age', {\rvalue: 22\r});\rconsole.log( obj ); // {name: \u0026quot;jack\u0026quot;, age: 22}\r 修改属性的 writable 将 writable 设置为 false 之后，无法直接修改属性值，必须使用 Object.defineProperty 方法修改其值。\nvar obj = { name: 'jack', age: 18 };\r// 此时可以直接修改 age 属性\robj.age = 22;\rconsole.log( obj.age ); // 22\r// 现在将 writable 设置为 false\rObject.defineProperty( obj, 'age', {\rwritable: false\r});\r// 再次直接对属性赋值，不起作用，也不报错\robj.age = 18;\rconsole.log( obj.age ); // 22\r// 此时使用 Object.defineProperty 方法修改，修改成功\rObject.defineProperty( obj, 'age', {\rvalue: 18\r});\rconsole.log( obj.age ); // 18\r// 将 `writable` 恢复为 `true` 之后可以直接进行赋值\rObject.defineProperty( obj, 'age', {\rwritable: true\r});\robj.age = 20;\rconsole.log( obj.age ); // 20\r enumerable enumerable 用来表示此属性是否可以被枚举，比如使用 for in 和 Object.keys() 时是否会被遍历。\nvar obj = { name: 'jack', age: 18 };\rfor (k in obj) {\rconsole.log(k, obj[k]);\r}\r// name jack\r// age 18\rconsole.log( Object.keys(obj) );\r// [ \u0026quot;name\u0026quot;, \u0026quot;age\u0026quot; ]\rconsole.log( Object.values(obj) );\r// [ \u0026quot;jack\u0026quot;, 18 ]\r// 然后将 age 属性的 `enumerable` 设置为 `false`，就会发现 age 属性不会被遍历到\rObject.defineProperty( obj, 'age', {\renumerable: false\r})\rfor (k in obj) {\rconsole.log(k, obj[k]);\r}\r// name jack\rconsole.log( Object.keys(obj) );\r// [ \u0026quot;name\u0026quot; ]\rconsole.log( Object.values(obj) );\r// [ \u0026quot;jack\u0026quot; ]\r set 和 get 先来看 get，get 方法会在获取 age 属性的时候执行，并将其返回值作为 age 属性的值。\nvar obj = { name: 'jack', age: 18 };\rObject.defineProperty( obj, 'age', {\rget: function () {\rreturn 'get age';\r}\r})\rconsole.log( obj.age );\r// \u0026quot;get age\u0026quot;\r 再来看 set\nvar obj = { name: 'jack', age: 18 };\rObject.defineProperty( obj, 'age', {\rset: function ( newValue ) {\rconsole.log( 'newValue:', newValue )\r}\r});\robj.age = 22;\rconsole.log( 'age:', obj.age )\r// newValue: 22\r// age: undefined\r set 方法接收一个参数，即将要给 age 设置的新值。\nset 方法的返回值是最终 age 属性的值，如果 set 方法没有返回值，则为 undefined。\nvar obj = { name: 'jack', age: 18 };\rObject.defineProperty( obj, 'age', {\rset: function ( newValue ) {\rreturn newValue;\r}\r});\robj.age = 22;\rconsole.log( 'age:', obj.age )\r// newValue: 22\r// age: undefined\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ad54766532fc9b403f063388ddab4c98","permalink":"/doc/oh-my-js/05-object/07-object.defineproperty/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/07-object.defineproperty/","section":"doc","summary":"::: tip Vue.js@2.x 的响应式系统就是利用 Object.defineProperty 实现的，参考 深入响应式原理 :::\n用法 这个方法在一个对象上定义一个新属性，或者修改一个已经存在的属性。并返回这个对象。\nObject.defineProperty(obj, prop, descriptor);\r  obj: 目标对象 prop: 要操作的属性 descriptor: 用于指定对象属性的特性，这些特性包括：  value: 属性的值，默认为 undefined writable: 属性的值是否可以被重写，默认为 true get: 获取属性值的时候触发的函数，默认为 undefined set: 设置属性值的时候触发的函数，默认为 undefined configurable: 是否可以删除目标属性或是否可以再次修改属性的特性，默认为 true enumerable: 此属性是否可以被枚举（使用for\u0026hellip;in或Object.","tags":null,"title":"Object.defineProperty","type":"docs"},{"authors":null,"categories":null,"content":"描述 ES6 引入 Object.entries 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 数组类型\n示例 1. 普通对象 var obj = { foo: 'bar', boo: 123 };\rconsole.log( Object.entries(obj) ); // [ [\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;], [\u0026quot;boo\u0026quot;, 123] ]\r 2. 类数组对象 var obj = { 0: 'a', 1: 'b', 2: 'c' };\rconsole.log( Object.entries(obj) ); // [ [\u0026quot;0\u0026quot;, \u0026quot;a\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;b\u0026quot;], [\u0026quot;2\u0026quot;, \u0026quot;c\u0026quot;] ]\r 3. 随机索引的类数组对象 var obj = { 100: 'a', 2: 'b', 7: 'c' };\rconsole.log( Object.values(obj) ); // [ [\u0026quot;2\u0026quot;, \u0026quot;b\u0026quot;], [\u0026quot;7\u0026quot;, \u0026quot;c\u0026quot;], [\u0026quot;100\u0026quot;, \u0026quot;a\u0026quot;] ]\r 4. 5. 异常 Object.values( 'foo' ); // [ 'f', 'o', 'o' ]  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"51c7cbb8dd0640659fec69fba1b4158f","permalink":"/doc/oh-my-js/05-object/04-object.entries/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/04-object.entries/","section":"doc","summary":"描述 ES6 引入 Object.entries 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 数组类型\n示例 1. 普通对象 var obj = { foo: 'bar', boo: 123 };\rconsole.","tags":null,"title":"Object.entries()","type":"docs"},{"authors":null,"categories":null,"content":"描述 ES6 引入 Object.is 方法，它用于比较两个值是否严格相等。\n相等运算符（==）会自动转换类型，严格相等运算符 NaN 不等于自身，而且 +0 等于 -0。\nObject.is() 方法和严格相等运算符基本一致，不同之处有两个，一是 +0 不等于 -0，二是 NaN 等于自身。\n参数 两个进行比较的值\n返回值 如果两个参数相等，返回 true ，否则返回 false 。\n示例 0. 基本使用 Object.is({}, {}); // false\rObject.is(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;); // true\r 1. Object.is() 不会自动转换类型 console.log(\u0026quot;5\u0026quot; == 5); // true\rconsole.log(Object.is(\u0026quot;5\u0026quot;, 5)); // false\r 2. Object.is() 和 严格相等（===）的区别 console.log(Object.is(NaN, NaN)); // true\rconsole.log(NaN === NaN); // false\rconsole.log(Object.is(-1, +1)); // false\rconsole.log(+1 === -1);\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"36ebde845f4c657b7399ee3127cedcde","permalink":"/doc/oh-my-js/05-object/06-object.is/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/06-object.is/","section":"doc","summary":"描述 ES6 引入 Object.is 方法，它用于比较两个值是否严格相等。\n相等运算符（==）会自动转换类型，严格相等运算符 NaN 不等于自身，而且 +0 等于 -0。\nObject.is() 方法和严格相等运算符基本一致，不同之处有两个，一是 +0 不等于 -0，二是 NaN 等于自身。\n参数 两个进行比较的值\n返回值 如果两个参数相等，返回 true ，否则返回 false 。\n示例 0. 基本使用 Object.is({}, {}); // false\rObject.","tags":null,"title":"Object.is()","type":"docs"},{"authors":null,"categories":null,"content":"描述 ES6 引入 Object.keys 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 一个表示给定对象的所有可枚举属性的字符串数组\n示例 0. 基本使用 var arr = {\rname: 'jack',\rage: 20,\rsex: 'man'\r};\rvar keys = Object.keys(arr); // [\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;sex\u0026quot;]  1. 简单数组 var arr = [ 'a', 'b', 'c' ];\rconsole.log( Object.keys(arr) ); // [ '0', '1', '2' ]\r 2. 类数组对象 var obj = { 0: 'a', 1: 'b', 2: 'c' };\rconsole.log( Object.keys(obj) ); // [ '0', '1', '2' ]\r 3. 随机索引的类数组对象 注意顺序，按照索引从小到大进行遍历。\nvar anObj = { 100: 'a', 2: 'b', 7: 'c' };\rconsole.log( Object.keys(anObj) ); // [ '2', '7', '100' ]\r 4. 包含不可枚举属性 var obj = Object.create({}, {\rgetFoo: {\rvalue: function () { return this.foo; }\r}\r});\robj.foo = 1;\rconsole.log( Object.keys(obj) ); // [ 'foo' ]\r 5. 异常处理 ES5 中，如果参数是原始值，会抛出异常。ES6 中则会强制转化为一个对象。\nObject.keys( 'foo' ); // TypeError: \u0026quot;foo\u0026quot; is not an object (ES5 code)\rObject.keys( 'foo' ); // [ '0', '1', '2' ]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"b83ef682bd3cb0eae0e492f3cb4fe77f","permalink":"/doc/oh-my-js/05-object/02-object.keys/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/02-object.keys/","section":"doc","summary":"描述 ES6 引入 Object.keys 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 一个表示给定对象的所有可枚举属性的字符串数组\n示例 0. 基本使用 var arr = {\rname: 'jack',\rage: 20,\rsex: 'man'\r};\rvar keys = Object.","tags":null,"title":"Object.keys()","type":"docs"},{"authors":null,"categories":null,"content":"描述 JavaScript 对象既可以有自己的属性，也可以从原型继承。通过 hasOwnProperty 可以区分继承属性和非继承属性。\n参数    参数 描述     prop String 类型，必需。要检测的属性名    返回值 布尔值，对象自身是否拥有被检测的属性。\n示例 判断自身属性 prop 是否存在 var obj = new Object();\robj.prop = 'ok';\rfunction changeObj () {\robj.newProp = obj.prop;\rdelete obj.prop;\r}\robj.hasOwnProperty('prop'); // true\rchangeObj();\robj.hasOwnProperty('prop'); // false\r 区分自身属性和继承属性 var obj = new Object();\robj.prop = 'ok';\robj.hasOwnProperty('prop'); // true\robj.hasOwnProperty('toString'); // false\robj.hasOwnProperty('hasOwnProperty'); // false\r 在遍历一个对象所有自身属性时使用 注意：for...in 循环只会遍历可枚举属性\nvar obj = new Object();\robj.prop = 'ok';\rObject.prototype.name = 'name';\rfor (var k in obj) {\rif (obj.hasOwnProperty(k)) {\rconsole.log('hasOwnProperty: ', k);\r} else {\rconsole.log('Not hasOwnProperty: ', k);\r}\r}\r hasOwnProperty 被改写 var obj = {\rhasOwnProperty: function () {\rreturn false;\r},\rprop: 'ok'\r};\robj.hasOwnProperty('prop'); // 永远都返回 false\r// 为避免这种情况，可以使用 Object 原型链上的 hasOwnProperty 属性来判断\rObject.prototype.hasOwnProperty.call(obj, 'prop');\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"3a81188417ea0feeb0a29baa18050119","permalink":"/doc/oh-my-js/05-object/01-object.prototype.hasownproperty/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/01-object.prototype.hasownproperty/","section":"doc","summary":"描述 JavaScript 对象既可以有自己的属性，也可以从原型继承。通过 hasOwnProperty 可以区分继承属性和非继承属性。\n参数    参数 描述     prop String 类型，必需。要检测的属性名    返回值 布尔值，对象自身是否拥有被检测的属性。\n示例 判断自身属性 prop 是否存在 var obj = new Object();\robj.","tags":null,"title":"Object.prototype.hasOwnProperty()","type":"docs"},{"authors":null,"categories":null,"content":"描述 ES6 引入 Object.values 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 数组类型\n示例 1. 普通对象 var obj = { foo: 'bar', boo: 123 };\rconsole.log( Object.values(obj) ); // [ 'bar', 123 ]\r 2. 类数组对象 var obj = { 0: 'a', 1: 'b', 2: 'c' };\rconsole.log( Object.values(obj) ); // [ 'a', 'b', 'c' ]\r 3. 随机索引的类数组对象 var obj = { 100: 'a', 2: 'b', 7: 'c' };\rconsole.log( Object.values(obj) ); // [ 'b', 'c', 'a' ]\r 4. 5. 异常 Object.values( 'foo' ); // [ 'f', 'o', 'o' ]  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"993fcd6ed5c78c78bac25431f18696ee","permalink":"/doc/oh-my-js/05-object/03-object.values/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/05-object/03-object.values/","section":"doc","summary":"描述 ES6 引入 Object.values 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值\n参数    参数 描述     obj Object 类型，必需。要处理的对象    返回值 数组类型\n示例 1. 普通对象 var obj = { foo: 'bar', boo: 123 };\rconsole.","tags":null,"title":"Object.values()","type":"docs"},{"authors":null,"categories":null,"content":"padStart '7'.padStart(2, 0); // \u0026quot;07\u0026quot;\r padEnd 相关文章 \rJS字符串补全方法padStart()和padEnd()简介\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"6cea8a58204203fa2287810915db347a","permalink":"/doc/oh-my-js/04-string/009-string.prototype-padstart-padend/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/009-string.prototype-padstart-padend/","section":"doc","summary":"padStart '7'.padStart(2, 0); // \u0026quot;07\u0026quot;\r padEnd 相关文章 \rJS字符串补全方法padStart()和padEnd()简介","tags":null,"title":"padStart 和 padEnd","type":"docs"},{"authors":null,"categories":null,"content":"描述 在一个指定字符串中执行一个搜索匹配。返回一个数组或 null。\n参数    参数 描述     string 必需。要匹配正则表达式的字符串。    返回值 如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。\n返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组元素填充到后面。\n如果匹配失败，返回 null。\n示例 返回值 var str = 'leftTop';\rvar reg = /^([a-z]*)([A-Z]\\w*)*/;\rvar result = reg.exec(str);\rconsole.log( result );\r// [\r// 0: \u0026quot;leftTop\u0026quot;\r// 1: \u0026quot;left\u0026quot;\r// 2: \u0026quot;Top\u0026quot;\r// groups: undefined\r// index: 0\r// input: \u0026quot;leftTop\u0026quot;\r// length: 3\r// ]\r 数组第一个元素：完全匹配成功的文本\n数组第二个元素：匹配到正则第一个括号内表达式的文本\n数组第三个元素：匹配到正则第二个括号内表达式的文本\n（以此类推……）\n数组的 index 属性：匹配成功的文本首个字符在原表达式中的索引\n数组的 input 属性：用于匹配正则表达式的原始字符串\n返回 null var reg = /abc/;\rvar str = 'javascript';\rvar result = reg.exec(str);\rconsle.log(result); // null\r 更新正则表达式对象的属性 正则表达式在有 g 标志的情况下，每次执行 exec() 方法后，会更新正则表达式的 lastIndex 属性。\nvar reg = /(hello \\S+)/g; // 有 g 标志\rvar str = 'This is a hello world! This is a hello regexp!'\rconsole.log(reg.lastIndex); // 0\rreg.exec(str);\r// [\r// 0: \u0026quot;hello world!\u0026quot;\r// 1: \u0026quot;hello world!\u0026quot;\r// groups: undefined\r// index: 10\r// input: \u0026quot;This is a hello world! This is a hello regexp!\u0026quot;\r// length: 2\r// ]\rconsole.log(reg.lastIndex); // 22\r// 即 world! 后面的那个空格的索引\rreg.exec(str); // 第二次执行 exec() 时，从 reg.lastIndex 开始向后索引\r// [\r// 0: \u0026quot;hello regexp!\u0026quot;\r// 1: \u0026quot;hello regexp!\u0026quot;\r// groups: undefined\r// index: 33\r// input: \u0026quot;This is a hello world! This is a hello regexp!\u0026quot;\r// length: 2\r// ]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ba7053bb926ed293fe5a954146365639","permalink":"/doc/oh-my-js/06-regexp/03-regexp.prototype.exec/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/03-regexp.prototype.exec/","section":"doc","summary":"描述 在一个指定字符串中执行一个搜索匹配。返回一个数组或 null。\n参数    参数 描述     string 必需。要匹配正则表达式的字符串。    返回值 如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。\n返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组元素填充到后面。\n如果匹配失败，返回 null。\n示例 返回值 var str = 'leftTop';\rvar reg = /^([a-z]*)([A-Z]\\w*)*/;\rvar result = reg.","tags":null,"title":"Regexp.prototype.exec()","type":"docs"},{"authors":null,"categories":null,"content":"描述 检测字符串中是否含有与 regexp 相匹配的文本。\n参数    参数 描述     string 必需。要检测的字符串    返回值 如果字符串 string 中含有与 regexp 匹配的文本，就返回 true，否则返回 false\n示例 var reg = /java/i;\rreg.test('javascript'); // 返回 true\rreg.test('ECMAScript'); // 返回 false\r var reg = /java$/i;\rreg.test('javascript'); // false\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"2a107834a63ca56157861f2f8ef87421","permalink":"/doc/oh-my-js/06-regexp/02-regexp.prototype.test/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/02-regexp.prototype.test/","section":"doc","summary":"描述 检测字符串中是否含有与 regexp 相匹配的文本。\n参数    参数 描述     string 必需。要检测的字符串    返回值 如果字符串 string 中含有与 regexp 匹配的文本，就返回 true，否则返回 false\n示例 var reg = /java/i;\rreg.","tags":null,"title":"Regexp.prototype.test()","type":"docs"},{"authors":null,"categories":null,"content":"基本使用 判断字符串中是否包含另外一个字符串。\n\u0026quot;JavaScript\u0026quot;.includes(\u0026quot;Java\u0026quot;); // true\r\u0026quot;JavaScript\u0026quot;.includes(\u0026quot;java\u0026quot;); // false\r\u0026quot;Java\u0026quot;.includes(\u0026quot;JavaScript\u0026quot;); // false\r 深入研究 如果参数不是字符串呢？\n\u0026quot;123\u0026quot;.includes(123); // true\r\u0026quot;[object Object]\u0026quot;.includes({}); // true\r\u0026quot;\u0026quot;.includes([]); // true\r\u0026quot;true\u0026quot;.includes(true); // true\r\u0026quot;null\u0026quot;.includes(null); // true\r\u0026quot;NaN\u0026quot;.includes(NaN); // true\r\u0026quot;undefined\u0026quot;.includes(); // true\r 相信你看了上面的几个例子，会和我一样做出一个大胆猜测： includes 方法内部会首先对参数进行字符串转化的操作，因为\n将参数转化为字符串，实际上是调用了构造函数 String() 方法：\nString({});\r// \u0026quot;[object Object]\u0026quot;\rString([]);\r// \u0026quot;\u0026quot;\rString(true);\r// \u0026quot;true\u0026quot;\rString(333);\r// \u0026quot;333\u0026quot;\rString(null);\r// \u0026quot;null\u0026quot;\rString(NaN);\r// \u0026quot;NaN\u0026quot;\rString(undefined);\r// \u0026quot;undefined\u0026quot;\r 题外话 其实一开始我第一反应不是 String() 方法，而是 toString 方法，每种变量类型都拥有 toString 方法，但是有两个例外：undefined 和 null\nnull.toString()\r// Uncaught TypeError: Cannot read property 'toString' of null\r// undefined.toString()\r// Uncaught TypeError: Cannot read property 'toString' of undefined\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"5a00074082cf3c5f5f978d95bf20b2f2","permalink":"/doc/oh-my-js/04-string/006-string.prototype.includes/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/006-string.prototype.includes/","section":"doc","summary":"基本使用 判断字符串中是否包含另外一个字符串。\n\u0026quot;JavaScript\u0026quot;.includes(\u0026quot;Java\u0026quot;); // true\r\u0026quot;JavaScript\u0026quot;.includes(\u0026quot;java\u0026quot;); // false\r\u0026quot;Java\u0026quot;.includes(\u0026quot;JavaScript\u0026quot;); // false\r 深入研究 如果参数不是字符串呢？\n\u0026quot;123\u0026quot;.includes(123); // true\r\u0026quot;[object Object]\u0026quot;.includes({}); // true\r\u0026quot;\u0026quot;.includes([]); // true\r\u0026quot;true\u0026quot;.includes(true); // true\r\u0026quot;null\u0026quot;.includes(null); // true\r\u0026quot;NaN\u0026quot;.","tags":null,"title":"String.prototype.includes","type":"docs"},{"authors":null,"categories":null,"content":"String.prototype.match String.prototype.matchAll ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"03ba8a370e81c0570804e205e56518ad","permalink":"/doc/oh-my-js/04-string/004.string.prototype.match/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/004.string.prototype.match/","section":"doc","summary":"String.prototype.match String.prototype.matchAll ","tags":null,"title":"String.prototype.match","type":"docs"},{"authors":null,"categories":null,"content":"描述 检测字符串中是否含有与 regexp 相匹配的文本。\n如果正则表达式不包含 g 标志，则 match() 方法返回值和 RegExp.exec() 返回值是相同的。\n如果正则表达式包含 g 标志，则返回一个数组，包含所有匹配的字符串，而不是匹配对象（即不会返回 input 属性和 index 属性）。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    返回值 见描述\n示例 是否包含 g 的区别 'This is a hello world!'.match(/(hello \\S+)/g); // [\u0026quot;hello world!\u0026quot;]\rvar matches = /(hello \\S+)/.exec('This is a hello world!');\rconsole.log(matches);\r// [\r// 0: \u0026quot;hello world!\u0026quot;\r// 1: \u0026quot;hello world!\u0026quot;\r// groups: ined\r// index: 10\r// input: s is a hello world!\u0026quot;\r// length: 2\r// ]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"c0a0b644c886141ac03337e3a9d3b8f5","permalink":"/doc/oh-my-js/04-string/05-string.prototype.match/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/05-string.prototype.match/","section":"doc","summary":"描述 检测字符串中是否含有与 regexp 相匹配的文本。\n如果正则表达式不包含 g 标志，则 match() 方法返回值和 RegExp.exec() 返回值是相同的。\n如果正则表达式包含 g 标志，则返回一个数组，包含所有匹配的字符串，而不是匹配对象（即不会返回 input 属性和 index 属性）。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    返回值 见描述","tags":null,"title":"String.prototype.match()","type":"docs"},{"authors":null,"categories":null,"content":"","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"1020c84e15fa26f202a48698ecc15232","permalink":"/doc/oh-my-js/04-string/008-string.prototype.repeat/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/008-string.prototype.repeat/","section":"doc","summary":"","tags":null,"title":"String.prototype.repeat()","type":"docs"},{"authors":null,"categories":null,"content":"描述 replace 方法接收两个参数，第一个参数在字符串中匹配到的内容会被第二个参数替换掉。\nreplace 方法不修改字符串本身，而只是返回一个新的替换后的字符串。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    示例 最简单的替换 var str = 'aabb';\rstr.replace('a', 'x');\r// 'xabb' 只有第一个字母 a 被替换为字母 x\r 第一个参数是正则 const time = '2019-04-01 13:10:10';\rconst date = new Date(time.replace(/-/g, '/'));\r 两个参数都是正则 将手机号码中间四位数字替换为星号 *.\nvar str = '18012345678';\rstr.replace(/(\\d{3})(\\d{4})(\\d{4})/, '$1****$3');\r// 180****5678\r 第二个参数是函数 当第二个参数是函数时，这个函数会当被当做迭代器使用，它接收的参数分别是：\n 匹配到的字符串 $1: 正则表达式分组内容，没有分组则没有该参数 $2: 第二个分组 \u0026hellip;更多的分组，如果有的话 匹配项在字符串中的 index 原字符串  这个方法可以用于获取查询字符串中的参数\n// 假设 url 如下\r// https://www.baidu.com/s?ie=UTF-8\u0026amp;wd=regexp\r// 可以使用 window.location.search.slice(1) 来获取查询字符串\rvar querystring = 'ie=UTF-8\u0026amp;wd=regexp';\rvar params = parse(querystring);\rconsole.log(params);\r// {ie: \u0026quot;UTF-8\u0026quot;, wd: \u0026quot;regexp\u0026quot;}\rfunction parse (querystring) {\rvar querystring = querystring || '';\r// 1. 参数的键名和键值都不包含=\u0026amp;这两个符号\r// 2. 键值可能为空\rvar reg = /([^=\u0026amp;]+)=([^=\u0026amp;]*)/ig;\rvar json = {};\rquerystring.replace(reg, function (match, $1, $2) {\rvar args = [].slice.call(arguments);\rconsole.log(args); // 打印参数\rjson[$1] = $2\r})\rreturn json;\r}\r// [\u0026quot;ie=UTF-8\u0026quot;, \u0026quot;ie\u0026quot;, \u0026quot;UTF-8\u0026quot;, 0, \u0026quot;ie=UTF-8\u0026amp;wd=regexp\u0026quot;]\r// [\u0026quot;wd=regexp\u0026quot;, \u0026quot;wd\u0026quot;, \u0026quot;regexp\u0026quot;, 9, \u0026quot;ie=UTF-8\u0026amp;wd=regexp\u0026quot;]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"eb32253352f2a1a8f3cf53514ff31bee","permalink":"/doc/oh-my-js/04-string/06-string.prototype.replace/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/06-string.prototype.replace/","section":"doc","summary":"描述 replace 方法接收两个参数，第一个参数在字符串中匹配到的内容会被第二个参数替换掉。\nreplace 方法不修改字符串本身，而只是返回一个新的替换后的字符串。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    示例 最简单的替换 var str = 'aabb';\rstr.replace('a', 'x');\r// 'xabb' 只有第一个字母 a 被替换为字母 x\r 第一个参数是正则 const time = '2019-04-01 13:10:10';\rconst date = new Date(time.","tags":null,"title":"String.prototype.replace()","type":"docs"},{"authors":null,"categories":null,"content":"描述 检测字符串中是否含有与 regexp 相匹配的文本。类似于 Regexp.prototype.test 方法。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    返回值 如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1\n示例 var reg = /java/i;\r'javascript'.search(reg); // 0\r'learn java'.search(reg); // 6\r'ECMAScript'.search(reg); // -1\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ba144f61caf6c43d34b90d95e45c293e","permalink":"/doc/oh-my-js/04-string/04-string.prototype.search/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/04-string.prototype.search/","section":"doc","summary":"描述 检测字符串中是否含有与 regexp 相匹配的文本。类似于 Regexp.prototype.test 方法。\n参数    参数 描述     regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    返回值 如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1\n示例 var reg = /java/i;\r'javascript'.","tags":null,"title":"String.prototype.search()","type":"docs"},{"authors":null,"categories":null,"content":"slice() 方法用于从字符串中切割出一部分，它接收两个参数：切割范围的起始索引和结束索引。\n例如：\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.slice(1, 2);\rconsole.log(str); // \u0026quot;github\u0026quot;\rconsole.log(newStr); // \u0026quot;i\u0026quot;\r 通过结果可以看出两点：\n 此方法不修改原始变量，需要定义新变量接收其返回值 切割范围包含起始索引，不包含结束索引  再来看第二个列子，省略结束索引参数：\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.slice(1);\rconsole.log(newStr); // \u0026quot;ithub\u0026quot;\r 第三个例子\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.slice(-3);\rconsole.log(newStr); // \u0026quot;hub\u0026quot;\r 第四个例子\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.slice(-3);\rconsole.log(newStr); // \u0026quot;hub\u0026quot;\r var str = \u0026quot;github\u0026quot;\rvar newStr = str.slice();\rconsole.log(newStr); // \u0026quot;github\u0026quot;\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"4e39b5eac422699e6b32812ae5907a23","permalink":"/doc/oh-my-js/04-string/002-string.prototype.slice/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/002-string.prototype.slice/","section":"doc","summary":"slice() 方法用于从字符串中切割出一部分，它接收两个参数：切割范围的起始索引和结束索引。\n例如：\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.slice(1, 2);\rconsole.log(str); // \u0026quot;github\u0026quot;\rconsole.log(newStr); // \u0026quot;i\u0026quot;\r 通过结果可以看出两点：\n 此方法不修改原始变量，需要定义新变量接收其返回值 切割范围包含起始索引，不包含结束索引  再来看第二个列子，省略结束索引参数：\nvar str = \u0026quot;github\u0026quot;\rvar newStr = str.","tags":null,"title":"String.prototype.slice","type":"docs"},{"authors":null,"categories":null,"content":"描述 把一个字符串或者一个正则表达式当做分隔符，把一个字符串分割成一个数组，并返回这个数组。（不会改变原字符串）\n它和 Array.prototype.join() 的操作是相反的。\n参数    参数 描述     regexp 分隔符，必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    示例 例子 1 var str = \u0026quot;a🅱️c:d\u0026quot;;\rvar reg = /:/;\r// 以英文冒号: 为分隔符\rstr.split(reg); // [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;]\r 例子 2 var str = \u0026quot;hello world\u0026quot;;\rvar reg = /\\s/;\r// 以空格为分隔符\rstr.split(reg); // [ \u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot; ]\r 例子 3: 实例-转化查询字符串为 json 格式 示例网址：\rhttps://www.baidu.com/s?ie=UTF-8\u0026amp;wd=JavaScript，在这个页面指向下面代码会得到 url 中 JSON 格式的参数。\nfunction getParams(url) {\rif (!url || typeof url !== \u0026quot;string\u0026quot;) {\rreturn {};\r}\r// 得到 ? 后面的查询字符串\rvar qs = url.split(\u0026quot;?\u0026quot;)[1];\r// 通过 \u0026amp; 分隔不同的参数\rvar qsArr = qs.split(\u0026quot;\u0026amp;\u0026quot;);\rvar json = {};\rqsArr.forEach(function(item) {\r// 通过 = 分隔参数的键名和键值\rvar temp = item.split(\u0026quot;=\u0026quot;);\rjson[temp[0]] = temp[1];\r});\rreturn json;\r}\rvar url = \u0026quot;https://www.baidu.com/s?ie=UTF-8\u0026amp;wd=JavaScript\u0026quot;;\rgetParams(url); // {ie: \u0026quot;UTF-8\u0026quot;, wd: \u0026quot;JavaScript\u0026quot;}\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"3af395ad7658c67fb89e0bb0168b9535","permalink":"/doc/oh-my-js/04-string/003.string.prototype.split/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/003.string.prototype.split/","section":"doc","summary":"描述 把一个字符串或者一个正则表达式当做分隔符，把一个字符串分割成一个数组，并返回这个数组。（不会改变原字符串）\n它和 Array.prototype.join() 的操作是相反的。\n参数    参数 描述     regexp 分隔符，必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象    示例 例子 1 var str = \u0026quot;a🅱️c:d\u0026quot;;\rvar reg = /:/;\r// 以英文冒号: 为分隔符\rstr.","tags":null,"title":"String.prototype.split","type":"docs"},{"authors":null,"categories":null,"content":"什么叫千位符\n将 12345678 转化为 12,345,678（注：暂时不考虑小数）。\n \r千位分隔符的完整攻略 \rjavascript 正则表达式 \r正则基础之 —— 环视 (Lookaround)  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"d29df84908a95312a6cad2da1116ee63","permalink":"/doc/oh-my-js/06-regexp/demo-mile-format/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/demo-mile-format/","section":"doc","summary":"什么叫千位符\n将 12345678 转化为 12,345,678（注：暂时不考虑小数）。\n \r千位分隔符的完整攻略 \rjavascript 正则表达式 \r正则基础之 —— 环视 (Lookaround)  ","tags":null,"title":"千位符","type":"docs"},{"authors":null,"categories":null,"content":"trim trim 创建字符串的一个副本，并移除字符串两端的连续空白符，然后返回新字符串（并不会修改原字符串本身）。\nvar str = ' a b c '\rvar newStr = str.trim()\rconsole.log(str) // \u0026quot; a b c \u0026quot;\rconsole.log(newStr) // \u0026quot;a b c\u0026quot;\r trimStart 和 trimLeft trimStart 会创建字符串的一个副本，并移除字符串**左端（开头）**的连续空白符，然后返回新字符串（并不会修改原字符串本身）。 trimLeft 是 trimStart 的别名。\nvar str = ' a b c '\rvar newStr1 = str.trimStart()\rvar newStr2 = str.trimLeft()\rconsole.log(newStr1) // \u0026quot;a b c \u0026quot;\rconsole.log(newStr2) // \u0026quot;a b c \u0026quot;\r trimEnd 和 trimRight trimRight 创建字符串的一个副本，并移除字符串**右端（结尾）**的连续空白符，然后返回新字符串（并不会修改原字符串本身）。trimRight 是 trimEnd 的别名。\nvar str = ' a b c '\rvar newStr1 = str.trimEnd()\rvar newStr2 = str.trimRight()\rconsole.log(newStr1) // \u0026quot; a b c\u0026quot;\rconsole.log(newStr2) // \u0026quot; a b c\u0026quot;\r 通过正则简单实现： if(!String.prototype.trim) {\rString.prototype.trim = function () {\rreturn this.replace(/^\\s+|\\s+$/g,'');\r};\r}\rif(!String.prototype.trimLeft) {\rString.prototype.trimLeft = function () {\rreturn this.replace(/^\\s+/,'');\r};\r}\rif(!String.prototype.trimRight) {\rString.prototype.trimRight = function () {\rreturn this.replace(/\\s+$/,'');\r};\r}\r 用到的正则：\n \\s 匹配任何空白字符 + 匹配至少 1 个元字符 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 | 或者 g 全局匹配  more：  更多的实现方式参考：\rJavaScript trim函数大赏 - 司徒正美 MDN 文档：\rString.prototype.trim() - MDN  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"a424cc7d7bcd9e868729d9a2f4a8f32f","permalink":"/doc/oh-my-js/04-string/005-string.prototype.trim/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/005-string.prototype.trim/","section":"doc","summary":"trim trim 创建字符串的一个副本，并移除字符串两端的连续空白符，然后返回新字符串（并不会修改原字符串本身）。\nvar str = ' a b c '\rvar newStr = str.trim()\rconsole.log(str) // \u0026quot; a b c \u0026quot;\rconsole.log(newStr) // \u0026quot;a b c\u0026quot;\r trimStart 和 trimLeft trimStart 会创建字符串的一个副本，并移除字符串**左端（开头）**的连续空白符，然后返回新字符串（并不会修改原字符串本身）。 trimLeft 是 trimStart 的别名。","tags":null,"title":"去除字符串的头尾空格","type":"docs"},{"authors":null,"categories":null,"content":"String.prototype.toLowerCase toLowerCase 将字符串转换为小写，会将调用该方法的字符串转为小写形式，并返回。\n不会影响字符串本身。\ntoLowerCase 返回一个新的字符串，转换为小写形式之后的字符串。\n例如：\nvar str = 'GitHub'\rvar newStr = str.toLowerCase();\rconsole.log(str); // GitHub\rconsole.log(newStr); // github\r String.prototype.toUpperCase() toUpperCase 会将调用该方法的字符串转为大写形式，并返回。\ntoUpperCase 不会影响字符串本身。\n返回一个新的字符串，转换为大写形式之后的字符串。\n例如：\nvar str = 'GitHub'\rvar newStr = str.toUpperCase();\rconsole.log(str); // GitHub\rconsole.log(newStr); // GITHUB\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"ad96040a5682106ce84c6b2d173f11f5","permalink":"/doc/oh-my-js/04-string/001-string.prototype-tolowercase-touppercase/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/001-string.prototype-tolowercase-touppercase/","section":"doc","summary":"String.prototype.toLowerCase toLowerCase 将字符串转换为小写，会将调用该方法的字符串转为小写形式，并返回。\n不会影响字符串本身。\ntoLowerCase 返回一个新的字符串，转换为小写形式之后的字符串。\n例如：\nvar str = 'GitHub'\rvar newStr = str.toLowerCase();\rconsole.log(str); // GitHub\rconsole.log(newStr); // github\r String.prototype.toUpperCase() toUpperCase 会将调用该方法的字符串转为大写形式，并返回。\ntoUpperCase 不会影响字符串本身。\n返回一个新的字符串，转换为大写形式之后的字符串。\n例如：\nvar str = 'GitHub'\rvar newStr = str.","tags":null,"title":"字符串大小写转换","type":"docs"},{"authors":null,"categories":null,"content":" italics big small anchor blink bold fontsize fontcolor link normalize  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"6c5d0ec529e1a50130d2a3f44d36fc7a","permalink":"/doc/oh-my-js/04-string/000-transform-string-to-tag/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/04-string/000-transform-string-to-tag/","section":"doc","summary":" italics big small anchor blink bold fontsize fontcolor link normalize  ","tags":null,"title":"将字符串转化为标签","type":"docs"},{"authors":null,"categories":null,"content":"隐藏手机号码中间 4 位数字：  前三位数字：^(\\d{3}) 中间 4 位数字：\\d{4} 最后 4 位数字：(\\d{4})$ 子表达式：() 中的内容是一个子表达式，$1 表示第一个子表达式，$2 表示第二个子表达式，依次类推。  var str = '18012345678'\rvar newStr = str.replace(/^(\\d{3})\\d{4}(\\d{4})$/, '$1****$2')\rconsole.log(newStr) // 180****5678\r 判断字符串是否为数字 要考虑的问题：\n 数字有正负 数字有整数和小数之分 特殊数字 0  进一步分析：\n 正负：以 - 开头为负数，直接以数字开头为正数，因此可以确定正则开头部分为 /^-?/； 整数：整数的第一位应当是大于 0 的数字，如果是多位整数，则后面几位数字范围是 0-9 ，对应的正则为 /[1-9][0-9]*$/ 小数：小数有整数部分和小数部分，通过小数点 . 分隔开。通过上面分析，整数部分应该是 /[1-9][0-9]*/ 。而小数点需转义为 /\\./ 。小数部分可以全为 0 ，如 10.00 ，因此小数部分无需过多限制，对应的正则为 /[0-9]+/ 。 0：对应的正则是 /0/ 。  整数、小数、0 三种情况的逻辑关系为“或”，因此需要将他们使用 | 连接合并起来:\nvar regNum = /(^-?[1-9][0-9]*$)|(^-?[1-9][0-9]*\\.[0-9]+)|(^-?0$)/\r 另外，元字符 \\d 等价于 [0-9]，上面正则也可以写成这样：\nvar regNum = /(^-?[1-9]\\d*$)|(^-?[1-9]\\d*\\.\\d+)|(^-?0$)/\r 取出指定字符 有这样一个字符串，穿插着“【男播】”、“【女播】”、“【正文】”、“同期声”、“【CLIP】”五个随机出现的词组，现在需要对这个字符串进行一些操作。\n提取“【男播】”与下一个相邻词组之间的内容：\nvar str = \u0026quot;【男播】aaa【男播】bbb【女播】ccc【正文】ddd【同期声】ccc【CLIP】ddd【男播】eee【女播】fff【男播】ggg\u0026quot;;\rvar reg = /男播】([^【]*)【|男播】([^【]*)$/gi;\rvar arr = [];\rstr.replace(reg, function (match, $1, $2) {\r$1 ? arr.push($1) : '';\r$2 ? arr.push($2) : '';\r})\rvar result = arr.join(' ');\rconsole.log(result);\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"52bccaab12a1d4c985db65900e5187ac","permalink":"/doc/oh-my-js/06-regexp/100-regexp-demos/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/100-regexp-demos/","section":"doc","summary":"隐藏手机号码中间 4 位数字：  前三位数字：^(\\d{3}) 中间 4 位数字：\\d{4} 最后 4 位数字：(\\d{4})$ 子表达式：() 中的内容是一个子表达式，$1 表示第一个子表达式，$2 表示第二个子表达式，依次类推。  var str = '18012345678'\rvar newStr = str.replace(/^(\\d{3})\\d{4}(\\d{4})$/, '$1****$2')\rconsole.log(newStr) // 180****5678\r 判断字符串是否为数字 要考虑的问题：","tags":null,"title":"正则表达式使用案例","type":"docs"},{"authors":null,"categories":null,"content":" 正则表达式验证工具： https://regexper.com/\n  \r正则表达式教程\n 创建正则表达式 通过构造函数创建 var reg1 = new RegExp('a');\rvar reg2 = new RegExp('[a-zA-Z]', 'gi');\rvar reg3 = new RegExp(/[a-zA-Z]/, 'gi');\r 通过字面量创建 var reg = /[a-zA-Z]/gi;\r 修饰符    修饰符 描述     i 执行对大小写不敏感的匹配   g 执行全局匹配（查找所有匹配，而非在找到第一个匹配后停止）   m 执行多行匹配   s 执行单行匹配    正则对象属性  属性均为只读，无法设置其值\n    属性 含义 默认值     global 是否全文搜索 false   ignoreCase 是否大小写敏感 false   multiline 多行搜索 false   lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置 无   source 正则表达式的文本字符串 无    示例：\nvar reg1 = /\\w/;\rvar reg2 = /\\w/gim;\rconsole.log(reg1.global); // false\rconsole.log(reg1.ignoreCase); // false\rconsole.log(reg1.multiline); // false\rconsole.log(reg1.source); // \u0026quot;\\w\u0026quot;\rconsole.log(reg2.global); // true\rconsole.log(reg2.ignoreCase); // true\rconsole.log(reg2.multiline); // true\rconsole.log(reg2.source); // \u0026quot;\\w\u0026quot;\r 方括号    表达式 描述     [abc] 匹配方括号之间的任何字符   [^abc] 匹配任何不在方括号之间的字符   [0-9] 匹配任何从 0 至 9 的数字   [a-z] 匹配任何从小写 a 到小写 z 的字符   [A-Z] 匹配任何从大写 A 到大写 Z 的字符   [A-z] 匹配任何从大写 A 到小写 z 的字符   [adgk] 匹配给定集合内的任何字符   [^adgk] 匹配给定集合外的任何字符   (red|blue|green) 匹配任何指定的选项    子表达式 用括号括起来的正则表达式。例如：\nvar str = 'hello world';\rvar reg = /(\\w*)\\s*(\\w*)/;\rvar ans = str.replace(reg, '$2 $1')\rconsole.log(ans); // world hello\r 如 /(\\w*)\\s*(\\w*)/ 中，第一个括号 (\\w*) 匹配到的字符串（本例中是 hello），记为 $1，第二个括号 (\\w*) 匹配到的字符串（本例中是 world），记为 $2。\n简单地说：从左到右，以分组的左括号为标志，第一个出现的分组的序号为 1，第二个为 2，以此类推。\n复杂地说：分组 0 对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用 (?:exp) 这样的语法来剥夺一个分组对组号分配的参与权。\n参考：\r我所认识的javascript正则表达式\n元字符 元字符是拥有特殊含义的字符：\n   元字符 描述     . 匹配除 \\n 以外的任何字符（注意元字符是小数点）。   \\w 匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_]   \\W 不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_]   \\s 匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v]   \\S 匹配任何非空白字符，相当于 [^\\s]   \\b 匹配单词边界   \\B 匹配非单词边界   \\d 匹配任何 0 到 9 之间的单个数字，相当于 [0-9]   \\D 不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9]   [\\u4e00-\\u9fa5] 匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 )    助记：\n w: word s: space d: digit  量词（限定符） 上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。\n下面是一些常见的限定符 ( 下表中 n 和 m 都是表示整数，并且 0 \u0026lt; n \u0026lt; m) ：\n   限定符 描述     {n} 匹配 n 个元字符   {n,} 匹配至少 n 个元字符   {n,m} 匹配 n 到 m 个元字符   * 匹配 0 到多个元字符，相当于 {0,}   ? 匹配 0 到 1 个元字符，相当于 {0,1}   + 匹配至少 1 个元字符，相当于 {1,}   ^ 字符串必须以指定的字符开始   $ 字符串必须以指定的字符结束    其他   由于在正则表达式中\\、?、*、^、$、+、(、)、|、{、[等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \\ ”，那么正则表达式应该这么写： \\\\+ 。\n  可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 ^(13)[4-9]\\d{8}$ 表示任意以 13 开头的移动手机号码。\n  另外对于中文字符的匹配是采用其对应的 Unicode 编码来匹配的，对于单个 Unicode 字符，如 \\u4e00 表示汉字“一”， \\u9fa5 表示汉字“龥”，在 Unicode 编码中这分别是所能表示的汉字的第一个和最后一个的 Unicode 编码，在 Unicode 编码中能表示 20901 个汉字。\n  关于 \\b 的用法，它代表单词的开始或者结尾，以字符串 123a 345b 456 789d 作为示例字符串，如果正则表达式是 \\b\\d{3}\\b，则仅能匹配 456 。\n  可以使用 | 来表示或的关系，例如 [z|j|q] 表示匹配 z 、 j 、 q 之中的任意一个字母。\n  正则验证工具： https://regexper.com/\n  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"f152b27631757bafea3af1d49fdcdcf1","permalink":"/doc/oh-my-js/06-regexp/00-regexp-basic/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/00-regexp-basic/","section":"doc","summary":"正则表达式验证工具： https://regexper.com/\n  \r正则表达式教程\n 创建正则表达式 通过构造函数创建 var reg1 = new RegExp('a');\rvar reg2 = new RegExp('[a-zA-Z]', 'gi');\rvar reg3 = new RegExp(/[a-zA-Z]/, 'gi');\r 通过字面量创建 var reg = /[a-zA-Z]/gi;\r 修饰符    修饰符 描述     i 执行对大小写不敏感的匹配   g 执行全局匹配（查找所有匹配，而非在找到第一个匹配后停止）   m 执行多行匹配   s 执行单行匹配    正则对象属性  属性均为只读，无法设置其值","tags":null,"title":"正则表达式基础知识","type":"docs"},{"authors":null,"categories":null,"content":"描述 在每个实例化的正则对象中，都存在一个 lastIndex 属性，初始值为 0 。\nlastIndex 属性是进行正则匹配操作的开始的位置\n如果正则表达式不带 g 标志，则 lastIndex 始终为 0。\n如果正则表达式带有 g 标志，匹配成功则将匹配内容最后一个字符串在原字符串中的索引加 1 设置为 lastIndex 的值，匹配失败则重置为 0。\n示例 返回值 var reg1 = /ab/;\rvar reg2 = /ab/g;\rvar str = 'abcabc';\rconsole.log(reg1.lastIndex, reg1.test(str)); // 0 true\rconsole.log(reg1.lastIndex, reg1.test(str)); // 0 true\rconsole.log(reg1.lastIndex, reg1.test(str)); // 0 true\rconsole.log(reg2.lastIndex, reg2.test(str)); // 0 true\rconsole.log(reg2.lastIndex, reg2.test(str)); // 2 true\rconsole.log(reg2.lastIndex, reg2.test(str)); // 5 false\r// 当 lastIndex 为 5 时，正则匹配从 str[5] 的位置开始，结果为 false\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"99a44a3dc31f7e014b8e99e3cd392899","permalink":"/doc/oh-my-js/06-regexp/01-regexp.prototype.lastindex/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/01-regexp.prototype.lastindex/","section":"doc","summary":"描述 在每个实例化的正则对象中，都存在一个 lastIndex 属性，初始值为 0 。\nlastIndex 属性是进行正则匹配操作的开始的位置\n如果正则表达式不带 g 标志，则 lastIndex 始终为 0。\n如果正则表达式带有 g 标志，匹配成功则将匹配内容最后一个字符串在原字符串中的索引加 1 设置为 lastIndex 的值，匹配失败则重置为 0。\n示例 返回值 var reg1 = /ab/;\rvar reg2 = /ab/g;\rvar str = 'abcabc';\rconsole.","tags":null,"title":"正则表达式的 lastIndex 属性","type":"docs"},{"authors":null,"categories":null,"content":"预查格式 (?=pattern)\n上代码 通俗点说，就是 预查不消耗字符串，仅仅是用来确认是否匹配成功。\nvar str = \u0026quot;abc\u0026quot;;\rvar reg1 = /a(?=b)bc/;\rvar reg2 = /a(b)bc/;\rconsole.log(reg1.test(str)); // true\rconsole.log(reg2.test(str)); // false\r reg1 中的预查 (?=b) 并没有消耗掉匹配到的字符 b，而是确认 a 后面的字符是 b，因此 a 后面的字符 bc 和 预查后面的正则 bc 匹配成功，最后结果为 true。\n而 reg2 中的 (b) 将 str 中的 b 消耗掉，str 中只剩一个字符 c，无法与 reg2 中 (b) 后面的 bc 相匹配，最后结果为 false。\n示例 千分制表示一个数字 如何给一串数字用千分制表示？比如 99999999999 变成 99, 999, 999, 999。\n $\u0026amp; 表示与正则表达式相匹配的字符\n var reg = /\\d{1,3}(?=(\\d{3})+$)/g;\rvar f = '99999999999'.replace(reg, '$\u0026amp;, ');\rconsole.log(f); // 99, 999, 999, 999\r 正则表达式中的 $ 很重要，它保证了每一个匹配到的字符串后面都是三个数字。如果没有 $，会怎样？\nvar reg = /\\d{1,3}(?=(\\d{3})+)/g;\rvar f = '99999999999'.replace(reg, '$\u0026amp;, ');\rconsole.log(f); // 999, 999, 99, 999\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"6ef9945ded98eea9d0c6fff666e72cc4","permalink":"/doc/oh-my-js/06-regexp/0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%A2%84%E6%9F%A5/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/06-regexp/0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%A2%84%E6%9F%A5/","section":"doc","summary":"预查格式 (?=pattern)\n上代码 通俗点说，就是 预查不消耗字符串，仅仅是用来确认是否匹配成功。\nvar str = \u0026quot;abc\u0026quot;;\rvar reg1 = /a(?=b)bc/;\rvar reg2 = /a(b)bc/;\rconsole.log(reg1.test(str)); // true\rconsole.log(reg2.test(str)); // false\r reg1 中的预查 (?=b) 并没有消耗掉匹配到的字符 b，而是确认 a 后面的字符是 b，因此 a 后面的字符 bc 和 预查后面的正则 bc 匹配成功，最后结果为 true。","tags":null,"title":"正则表达式预查","type":"docs"},{"authors":null,"categories":null,"content":"描述 方法 concat() 将创建并返回一个新数组，然后将所有参数都添加到新数组中。它并不修改原数组 。如果要进行 concat() 操作的参数是一个数组，那么添加的是数组中的元素，而不是数组。\n参数    参数 描述     valueX 必需。可以使具体的值，也可以是数组对象，可以是任意多个。    返回值 一个新数组\n示例  参数为具体的值  var arr = [1, 2];\rarr.concat(4, 5); // [ 1, 2, 4, 5 ]\r  参数为数组对象  var arr = [1, 2];\rarr.concat([4, 5]); // [ 1, 2, 4, 5 ]\r  多个参数  var arr = [1, 2];\rarr.concat([4, 5], [6, 7]); // [ 1, 2, 4, 5, 6, 7 ]\r  参数为数组对象，且元素也为数组对象  var arr = [1, 2];\rarr.concat(4, [5, [6, 7]]); // [ 1, 2, 4, 5, [ 6, 7 ] ]\r 模拟实现 /*\r* 模拟原生 Array.concat()\r*/\rArray.prototype.concat = function() {\rvar args = arguments;\rvar arr = this;\rfor (var i = 0; i \u0026lt; args.length; i++) {\rvar item = args[i];\rif (item instanceof Array) {\rfor (var j = 0; j \u0026lt; item.length; j++) {\rarr.push(item[j]);\r}\r} else {\rarr.push(item);\r}\r}\rreturn arr;\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"242c65b97eda87f82420528d547958fe","permalink":"/doc/oh-my-js/01-array-es3/01-array.prototype.concat/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/01-array.prototype.concat/","section":"doc","summary":"描述 方法 concat() 将创建并返回一个新数组，然后将所有参数都添加到新数组中。它并不修改原数组 。如果要进行 concat() 操作的参数是一个数组，那么添加的是数组中的元素，而不是数组。\n参数    参数 描述     valueX 必需。可以使具体的值，也可以是数组对象，可以是任意多个。    返回值 一个新数组\n示例  参数为具体的值  var arr = [1, 2];\rarr.","tags":null,"title":"Array.prototype.concat()","type":"docs"},{"authors":null,"categories":null,"content":"描述 所有的数组元素都被转化成字符串，再用一个分隔符将这些字符串连接起来。如果元素是 undefined 或者 null，则会被转换成空字符串。\n参数    参数 描述     separator 可选。 指定要选的分隔符，如果省略，则使用逗号为分隔符。    返回值 一个字符串\n示例 （1）数组元素为基本类型 var names = [\u0026quot;李白\u0026quot;, \u0026quot;杜甫\u0026quot;, \u0026quot;苏轼\u0026quot;];\rnames.join(); // \u0026quot;李白,杜甫,苏轼\u0026quot;\rnames.join(\u0026quot;、\u0026quot;); // \u0026quot;李白、杜甫、苏轼\u0026quot;\r （2）数组元素为数组对象 var arr = [1, 2, [3, 4]];\rarr.join(); // \u0026quot;1,2,3,4\u0026quot;\rarr.join(\u0026quot;+\u0026quot;); // \u0026quot;1+2+3,4\u0026quot;\r （3）数组元素为对象 var arr = [1, 2, { name: \u0026quot;zwc\u0026quot; }];\rarr.join(); // \u0026quot;1,2,[object Object]\u0026quot;\r （4）小结 实际上 join() 方法是对数组中每一项元素都进行了 toString() 操作转换成字符串之后进行的拼接。\nundefined 和 null 执行 toString() 则会报错，因此将其转化为空字符串\n({ type: \u0026quot;object\u0026quot; }.toString()); // \u0026quot;[object Object]\u0026quot;\r[3, 4].toString(); // \u0026quot;3,4\u0026quot;\rtrue.toString(); // \u0026quot;true\u0026quot;\r(function() {\rconsole.log(\u0026quot;hello\u0026quot;);\r}.toString()); // \u0026quot;function () { console.log('hello') }\u0026quot;\r 模拟实现 /*\r* 模拟原生 Array.join()\r*/\rArray.prototype.join = function() {\rvar sep = (arguments \u0026amp;\u0026amp; arguments[0]) || \u0026quot;,\u0026quot;;\rvar str = \u0026quot;\u0026quot;;\rfor (var i = 0; i \u0026lt; this.length; i++) {\rvar item = this[i];\ritem === undefined || null ? \u0026quot;\u0026quot; : item;\rstr += sep + item.toString();\r}\rreturn str.replace(sep, \u0026quot;\u0026quot;);\r};\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"a93db4427e45ae846b6e0daaee6afbf8","permalink":"/doc/oh-my-js/01-array-es3/02-array.prototype.join/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/02-array.prototype.join/","section":"doc","summary":"描述 所有的数组元素都被转化成字符串，再用一个分隔符将这些字符串连接起来。如果元素是 undefined 或者 null，则会被转换成空字符串。\n参数    参数 描述     separator 可选。 指定要选的分隔符，如果省略，则使用逗号为分隔符。    返回值 一个字符串\n示例 （1）数组元素为基本类型 var names = [\u0026quot;李白\u0026quot;, \u0026quot;杜甫\u0026quot;, \u0026quot;苏轼\u0026quot;];\rnames.","tags":null,"title":"Array.prototype.join()","type":"docs"},{"authors":null,"categories":null,"content":"描述 将一个或多个元素添加到数组的末尾，并返回新数组的长度（对原数组进行修改）\n参数    参数 描述     elementN 必需，个数为至少一个。被添加到数组末尾的元素。    返回值 新的 length 属性值。\n示例 var arr = [1, 2, 3];\rvar newLength1 = arr.push(4); // 4\rvar newLength2 = arr.push(5, 6); // 6\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"970a732d47673cda40454ba6cfd399be","permalink":"/doc/oh-my-js/01-array-es3/03-array.prototype.push/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/03-array.prototype.push/","section":"doc","summary":"描述 将一个或多个元素添加到数组的末尾，并返回新数组的长度（对原数组进行修改）\n参数    参数 描述     elementN 必需，个数为至少一个。被添加到数组末尾的元素。    返回值 新的 length 属性值。\n示例 var arr = [1, 2, 3];\rvar newLength1 = arr.","tags":null,"title":"Array.prototype.push()","type":"docs"},{"authors":null,"categories":null,"content":"描述 从一个数组中删除并返回最后一个元素。（修改原数组）\n参数 无\n返回值 从数组中删除的元素（当数组为空时返回 undefined）\n示例 var arr = [1, 2, 3];\rvar delEle = arr.pop(); // 3\r[].pop(); // undefined\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"1afb53b0bdaa778fcbfa8f248e92a63f","permalink":"/doc/oh-my-js/01-array-es3/04-array.prototype.pop/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/04-array.prototype.pop/","section":"doc","summary":"描述 从一个数组中删除并返回最后一个元素。（修改原数组）\n参数 无\n返回值 从数组中删除的元素（当数组为空时返回 undefined）\n示例 var arr = [1, 2, 3];\rvar delEle = arr.pop(); // 3\r[].pop(); // undefined\r ","tags":null,"title":"Array.prototype.pop()","type":"docs"},{"authors":null,"categories":null,"content":"描述 从一个数组中删除并返回第一个元素。（修改原数组）\n参数 无\n返回值 从数组中删除的元素（当数组为空时返回 undefined）\n示例 var arr = [1, 2, 3];\rvar delEle = arr.shift(); // 1\r[].shift(); // undefined\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"83237cc00d6139e4010938979268432b","permalink":"/doc/oh-my-js/01-array-es3/05-array.prototype.shift/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/05-array.prototype.shift/","section":"doc","summary":"描述 从一个数组中删除并返回第一个元素。（修改原数组）\n参数 无\n返回值 从数组中删除的元素（当数组为空时返回 undefined）\n示例 var arr = [1, 2, 3];\rvar delEle = arr.shift(); // 1\r[].shift(); // undefined\r ","tags":null,"title":"Array.prototype.shift()","type":"docs"},{"authors":null,"categories":null,"content":"描述 将一个或多个元素添加到数组的开头，并返回新数组的长度。（修改原数组）\n参数    参数 描述     elementN 必需，个数为至少一个。要添加到数组开头的元素    示例 [].unshift(); // undefined\rvar arr = [1, 2, 3];\rvar newLength1 = arr.unshift(4); // 4\rconsole.log(arr); // [ 4, 1, 2, 3 ]\rvar newLength2 = arr.unshift(5, 6); // 6\rconsole.log(arr); // [ 5, 6, 4, 1, 2, 3 ]\rvar newLength3 = arr.unshift([7, 8]); // 7\rconsole.log(arr); // [ [7, 8], 5, 6, 4, 1, 2, 3 ]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"51be5d8b78c8b66a0cc248723681fb0e","permalink":"/doc/oh-my-js/01-array-es3/06-array.prototype.unshift/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/06-array.prototype.unshift/","section":"doc","summary":"描述 将一个或多个元素添加到数组的开头，并返回新数组的长度。（修改原数组）\n参数    参数 描述     elementN 必需，个数为至少一个。要添加到数组开头的元素    示例 [].unshift(); // undefined\rvar arr = [1, 2, 3];\rvar newLength1 = arr.","tags":null,"title":"Array.prototype.unshift()","type":"docs"},{"authors":null,"categories":null,"content":"描述 对数组实例的部分元素进行浅拷贝，拷贝的范围由参数 begin 和 end 决定，不会修改原数组。\n既然是浅拷贝，那么：\n  如果该元素是个对象引用（不是实际的对象）， slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n  对于字符串、数字和布尔值来说（不是 String、Number 和 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或者数字或者布尔值，将不会影响另一个数组。\n  如果向两个数组中任一一个数组中添加了新元素，则另一个不会受到影响。\n  参数 begin（可选） 从该索引处开始提取原数组中的元素。如果该参数为负数，则表示从原数组中的倒数第几个开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin ，则 slice 从索引 0 开始。\nend （可选） 在该索引处结束提取原数组元素，slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）\nslice(1, 4) 提取原数组中的第二个元素开始知道第四个元素的所有元素（索引为 1,2,3 的元素）\n如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取。slice(-2, -1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。\n如果 end 被省略，则 slice 会一直提取到原数组末尾。\n如果 end 大于数组长度， slice 也会一直提取到原数组末尾。\n返回值 返回数组类型的切割结果\n示例  省略 begin 和 end  var arr = [1, 2, 3];\rvar newArr = arr.slice(); // [ 1, 2, 3 ]\rarr.push(4);\rconsole.log(arr); // [ 1, 2, 3, 4 ]\rconsole.log(newArr); // [ 1, 2, 3 ]\r 其他用法  数组浅拷贝  var arr = [1, 2, 3];\rvar newArr = arr.slice();\rconsole.log(newArr); // [1, 2, 3]\r// 修改原数组和新数组，相互不影响\rarr.push(4);\rnewArr.push(5);\rconsole.log(arr); // [1, 2, 3, 4]\rconsole.log(newArr); // [1, 2, 3, 5]\r  将类数组对象转化为数组  // 转化元素\rArray.prototype.slice.call(document.querySelectorAll(\u0026quot;div\u0026quot;));\r// 或者使用简单的写法\r[].slice.call(document.querySelectorAll(\u0026quot;div\u0026quot;));\r// 转化函数的参数列表\rfunction fn() {\rvar args = arguments;\rvar arr = Array.prototype.slice.call(args);\rconsole.log(args);\rconsole.log(arr);\r}\rfn(1, 2, 3);\r// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\r// [1, 2, 3]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"9f386726014020a05bcd4ae3124f8d4b","permalink":"/doc/oh-my-js/01-array-es3/07-array.prototype.slice/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/07-array.prototype.slice/","section":"doc","summary":"描述 对数组实例的部分元素进行浅拷贝，拷贝的范围由参数 begin 和 end 决定，不会修改原数组。\n既然是浅拷贝，那么：\n  如果该元素是个对象引用（不是实际的对象）， slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n  对于字符串、数字和布尔值来说（不是 String、Number 和 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或者数字或者布尔值，将不会影响另一个数组。\n  如果向两个数组中任一一个数组中添加了新元素，则另一个不会受到影响。\n  参数 begin（可选） 从该索引处开始提取原数组中的元素。如果该参数为负数，则表示从原数组中的倒数第几个开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin ，则 slice 从索引 0 开始。","tags":null,"title":"Array.prototype.slice()","type":"docs"},{"authors":null,"categories":null,"content":"描述 在指定索引处删除数组元素或者增加数组元素。因此，splice() 方法要比 push()，pop()，shift()，unshift() 更为强大和灵活，当然，也更复杂。\n参数 start 指定修改的开始位置。如果超出了数组的长度，则从数组末尾开始添加内容，如果是负值，则表示从数组末位开始的第几位。\n若只使用 start 参数而不使用 deleteCount、item，如：array.splice(start)，表示删除 [start, end] 的元素。\ndeleteCount （可选） 表示要移除的数组的元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应该添加一个新元素。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素豆浆被删除（含第 start 位）。\n如果 deleteCount 被省略，则相当于 arr.lengtrh-start。\nitem1, item2, ... （可选） 要添加进数组的元素，从 start 位置开始，如果不指定，则 splice 将只删除数组元素。\n返回值 返回由被删除的元素组成的一个数组。\n如果只删除了一个元素，则返回只包含了一个元素的数组，如果没有删除元素，则返回空数组。\n示例 splice 功能很强大，可以在指定位置增加或删除元素\n 删除  var arr = [1, 2, 3];\rarr.splice(0, 2);\r// 从索引 0 开始删除 2 个元素（包含索引为 0 的元素）\rconsole.log(arr);\r// [3]\r  增加  var arr = [1, 2, 3];\rarr.splice(0, 0, 4, 5);\r// 如果不需要删除元素，将第二个参数指定为 0\r// 从索引 0 开始删除 0 个元素，将元素 4 和 5 从索引为 0 的位置依次插入\rconsole.log(arr);\r// [4, 5, 1, 2, 3]\r  同时删除和增加  var arr = [1, 2, 3];\rarr.splice(1, 2, 4, 5); // [ 2, 3 ]\rconsole.log(arr);\r// [ 1, 4, 5 ]\r// 从索引为 1 的位置开始删除 2 个元素，然后将 4 和 5 在索引为 1 处插入\r 边界情况  只有 start  var arr = [1, 2, 3];\rarr.splice(2); // [ 3 ]\rconsole.log(arr); // [ 1, 2 ]\r  deleteCount 为 0  var arr = [1, 2, 3];\rarr.splice(1, 0); // []\rconsole.log(arr); // [ 1, 2, 3 ]\r  deleteCount 大于 start 之后元素的总和  var arr = [1, 2, 3, 4];\rarr.splice(1, 4); // [ 2, 3, 4 ]\rconsole.log(arr); // [ 1 ]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"34276c558c78b8aaaa3e21c25930211b","permalink":"/doc/oh-my-js/01-array-es3/08-array.prototype.splice/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/08-array.prototype.splice/","section":"doc","summary":"描述 在指定索引处删除数组元素或者增加数组元素。因此，splice() 方法要比 push()，pop()，shift()，unshift() 更为强大和灵活，当然，也更复杂。\n参数 start 指定修改的开始位置。如果超出了数组的长度，则从数组末尾开始添加内容，如果是负值，则表示从数组末位开始的第几位。\n若只使用 start 参数而不使用 deleteCount、item，如：array.splice(start)，表示删除 [start, end] 的元素。\ndeleteCount （可选） 表示要移除的数组的元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应该添加一个新元素。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素豆浆被删除（含第 start 位）。\n如果 deleteCount 被省略，则相当于 arr.","tags":null,"title":"Array.prototype.splice()","type":"docs"},{"authors":null,"categories":null,"content":"描述 reverse() 方法用于颠倒数组中元素的顺序。（修改原数组）\n参数 无\n返回值 返回颠倒顺序后的数组。\n示例 var numbers = [1, 2, 3, 4];\rnumbers.reverse();\rconsole.log(numbers); // [4, 3, 2, 1]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"9ab9d76dcd169fc28d0d4208b5edf7de","permalink":"/doc/oh-my-js/01-array-es3/09-array.prototype.reverse/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/09-array.prototype.reverse/","section":"doc","summary":"描述 reverse() 方法用于颠倒数组中元素的顺序。（修改原数组）\n参数 无\n返回值 返回颠倒顺序后的数组。\n示例 var numbers = [1, 2, 3, 4];\rnumbers.reverse();\rconsole.log(numbers); // [4, 3, 2, 1]\r ","tags":null,"title":"Array.prototype.reverse()","type":"docs"},{"authors":null,"categories":null,"content":"描述 对数组的元素进行排序（修改原数组），并返回数组，默认排序顺序是根据字符串 Unicode 码点。\n为了实现排序，sort() 方法会调用每个数组项的 toString() 方法，然后比较得到的字符串，以确定如何排序。\n另外，sort() 可以接受一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。\n参数    参数 描述     compareFunction function 类型，可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为字符串的各个字符的 Unicode 位点进行排序    返回值 返回排序后的数组，原数组已经被排序后的数组代替。\n示例 一维数组排序  不指定排序方法  var scores = [1, 10, 21, 2];\rscores.sort();\rconsole.log(scores); // [ 1, 10, 2, 21 ]\r// 10 在 2 之前，这是因为在 Unicode 指针顺序中\u0026quot;10\u0026quot;在\u0026quot;2\u0026quot;之前\r  按数字大小升序  var numbers = [4, 2, 5, 1, 3];\rnumbers.sort(function(a, b) {\rreturn a - b;\r});\rconsole.log(numbers); // [ 1, 2, 3, 4, 5 ]\r  按数字大小降序  var numbers = [4, 2, 5, 1, 3];\rnumbers.sort(function(a, b) {\rreturn b - a;\r});\rconsole.log(numbers); // [ 1, 2, 3, 4, 5 ]\r 二维数组排序 数组元素为对象，按照对象某个属性对其排序，在表格排序中常常见到。\n按照 sortNo 属性从小到大排序： var arr = [\r{ sortNo: 2 },\r{ sortNo: 1 },\r{ sortNo: 5 },\r{ sortNo: 6 },\r{ sortNo: 7 },\r{ sortNo: 3 },\r{ sortNo: 9 },\r{ sortNo: 4 },\r{ sortNo: 0 }\r];\rarr.sort(function(a, b) {\rreturn a.sortNo - b.sortNo;\r});\rconsole.log(arr);\r//输出结果\r//{ 'sortNo': 0}\r//{ 'sortNo': 1}\r//{ 'sortNo': 2}\r//{ 'sortNo': 3}\r//{ 'sortNo': 4}\r//{ 'sortNo': 5}\r//{ 'sortNo': 6}\r//{ 'sortNo': 7}\r//{ 'sortNo': 9}\r 多条件排序 按照 sortNo 属性从小到大排序，如果 sortNo 相同，则按照 sortNo2 从大到小排序：\nvar arr = [\r{ sortNo: 2, sortNo2: 3 },\r{ sortNo: 1, sortNo2: 3 },\r{ sortNo: 5, sortNo2: 3 },\r{ sortNo: 6, sortNo2: 3 },\r{ sortNo: 7, sortNo2: 3 },\r{ sortNo: 3, sortNo2: 4 },\r{ sortNo: 3, sortNo2: 2 },\r{ sortNo: 3, sortNo2: 1 },\r{ sortNo: 3, sortNo2: 3 },\r{ sortNo: 8, sortNo2: 3 },\r{ sortNo: 4, sortNo2: 1 },\r{ sortNo: 4, sortNo2: 2 }\r];\rarr.sort(function(a, b) {\rif (a.sortNo == b.sortNo) {\rreturn b.sortNo2 - a.sortNo2;\r}\rreturn a.sortNo - b.sortNo;\r});\rconsole.log(arr);\r// [\r// {sortNo: 1, sortNo2: 3}\r// {sortNo: 2, sortNo2: 3}\r// {sortNo: 3, sortNo2: 4}\r// {sortNo: 3, sortNo2: 3}\r// {sortNo: 3, sortNo2: 2}\r// {sortNo: 3, sortNo2: 1}\r// {sortNo: 4, sortNo2: 2}\r// {sortNo: 4, sortNo2: 1}\r// {sortNo: 5, sortNo2: 3}\r// {sortNo: 6, sortNo2: 3}\r// {sortNo: 7, sortNo2: 3}\r// {sortNo: 8, sortNo2: 3}\r// ]\r 数字数组随机排序（洗牌算法） 将下面代码在 chrome 开发工具的 console 控制台执行，每次执行都会打印不同的结果。\nvar arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ];\rarr.sort(function(a, b) {\rreturn Math.random() \u0026gt; 0.5 ? 1 : -1;\r});\rconsole.log(arr);\r// [9, 7, 10, 5, 4, 13, 3, 8, 6, 12, 11]\r ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"5a1f7f8ca927abd80f5478fa161ed280","permalink":"/doc/oh-my-js/01-array-es3/10-array.prototype.sort/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/doc/oh-my-js/01-array-es3/10-array.prototype.sort/","section":"doc","summary":"描述 对数组的元素进行排序（修改原数组），并返回数组，默认排序顺序是根据字符串 Unicode 码点。\n为了实现排序，sort() 方法会调用每个数组项的 toString() 方法，然后比较得到的字符串，以确定如何排序。\n另外，sort() 可以接受一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。\n参数    参数 描述     compareFunction function 类型，可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为字符串的各个字符的 Unicode 位点进行排序    返回值 返回排序后的数组，原数组已经被排序后的数组代替。","tags":null,"title":"Array.prototype.sort()","type":"docs"},{"authors":null,"categories":null,"content":"Star\n","date":1593388800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1593388800,"objectID":"ae35922a2bbbe9c812f23d8f89f445c7","permalink":"/project/actionvue/","publishdate":"2020-06-29T00:00:00Z","relpermalink":"/project/actionvue/","section":"project","summary":"一款基于 Vue.js 开发的组件库","tags":["Demo"],"title":"ActionVue","type":"project"},{"authors":null,"categories":null,"content":"Vue.js 插件介绍 Vue.js 插件以一种更优雅的方式来为 Vue 添加全局功能。\n插件的使用方法很简单，只需要在 new Vue() 之前通过 Vue.js 提供的 use 方法来注册（启用）插件即可：\nimport MyPlugin from \u0026quot;MyPlugin\u0026quot;;\r// 要在 new Vue() 之前调用 use 方法\rVue.use(MyPlugin)\r// 也可以传入一个可选的选项对象\rVue.use(MyPlugin, { someOption: true })\r 如何自己开发一个插件 上面讲到，通过 Vue.use 方法来注册插件， Vue.use 方法接收两个参数，第一个是插件，第二个是一个可选的选项对象\nVue.use(MyPlugin, { someOption: true })\r 而 Vue.use 方法执行时是调用由 MyPlugin 提供的 install 方法，因此上面代码相当于：\nMyPlugin.install(Vue, { someOption: true })\r install 方法接收两个参数，Vue 构造函数和调用插件时传入的可选的选项对象。\n因此，只要是一个向外暴露 install 方法的模块，就可以作为 Vue 的插件，例如：\n// MyPlugin.js\rMyPlugin.install = function (Vue, options) {\rconsole.log('hello, MyPlugin');\r}\rexport default MyPlugin;\r 这便是一个最简单的 Vue.js 插件了。\n当然，我们开发插件不可能只是为了打印一句话，而是有更重要的使命等待我们去完成，因为 install 方法第一个参数是 Vue 构造函数，所以你可以围绕着 Vue 来扩展更多更强大的功能，另外 install 第二个参数可以接收一个配置选项对象，这样可以使你提供的功能更加灵活更具有可配置性。\nMyPlugin.install = function (Vue, options) {\r// 1. 添加全局方法或属性\rVue.myGlobalMethod = function () {\r// 逻辑...\r}\r// 2. 添加全局资源\rVue.directive('my-directive', {\rbind (el, binding, vnode, oldVnode) {\r// 逻辑...\r}\r})\r// 3. 注入组件选项\rVue.mixin({\rcreated: function () {\r// 逻辑...\r}\r})\r// 4. 添加实例方法\rVue.prototype.$myMethod = function (methodOptions) {\r// 逻辑...\r}\r}\r ps: 有的同学担心插件会被多次注册，其实 Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。\nlive demos 我们常见的库 Element UI 也是以插件形式引入，而且组件库内部的单个组件也都是插件形式存在，如 ElButton\n另外，\rawesome-vue 集合了大量由社区贡献的插件和库，有兴趣的同学可以自行研究学习。\n相关链接：  \rElement UI 文档 \rElement UI 源码 \r插件 - Vue.js 文档   本文完，感谢阅读。😜\n","date":1574926783,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1574926783,"objectID":"566434bb0e4c8e8e64b67b8a802689f0","permalink":"/post/2019/2019-11-28-how-to-create-a-plugin-of-vue.js/","publishdate":"2019-11-28T15:39:43+08:00","relpermalink":"/post/2019/2019-11-28-how-to-create-a-plugin-of-vue.js/","section":"post","summary":"Vue.js 插件介绍 Vue.js 插件以一种更优雅的方式来为 Vue 添加全局功能。\n插件的使用方法很简单，只需要在 new Vue() 之前通过 Vue.js 提供的 use 方法来注册（启用）插件即可：\nimport MyPlugin from \u0026quot;MyPlugin\u0026quot;;\r// 要在 new Vue() 之前调用 use 方法\rVue.use(MyPlugin)\r// 也可以传入一个可选的选项对象\rVue.use(MyPlugin, { someOption: true })\r 如何自己开发一个插件 上面讲到，通过 Vue.","tags":["vue.js","plugin"],"title":"如何创建一个 Vue.js 插件","type":"post"},{"authors":null,"categories":null,"content":"Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中\nAxios 有以下特点：\n 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造)  axios 的详细使用都可以在 https://github.com/axios/axios 中看到，本文主要将在项目实践中如何进一步封装 axios ，使得 axios 更符合实际需求。\n封装步骤 全局配置 全局配置是指配置 baseURL timeout 等选项。\n全局配置会影响到每个请求，可以直接对 axios 配置，也可以创建 axios 的实例，对实例进行配置。\naxios 和 axios 实例的区别就在于，axios 可以创建多个实例，不同实例之间的配置可以不同，并且不会影响到 axios 这个源头。\n直接配置 axios：\naxios.defaults.baseURL = 'https://api.example.com';\raxios.defaults.timeout = 2000;\r 或者配置 axios 实例：\nimport axios from \u0026quot;axios\u0026quot;;\r// 创建 axios 实例\rconst request = axios.create({\rbaseURL: \u0026quot;https://api.example.com\u0026quot;,\rtimeout: 2000, // 请求超时时间\r});\r 拦截器 axios 拦截器分为「请求拦截器」和「响应拦截器」，它们相当于是项目 http 请求的大门。\n每次发送请求时要经过「请求拦截器」这道门，每次请求得到响应时也要经过「响应拦截器」这道门。\n有了拦截器，方便我们对每个请求进行一些处理，比如：\n 发送请求时，判断用户的登录状态或者用户权限，不满足条件的或者跳转登录页面或者弹窗提示 发送请求时，添加特定的 headers 请求得到响应时，根据响应状态码做不同处理：  200: 响应成功 404: 未找到资源 409: 用户没有相应权限    import axios from \u0026quot;axios\u0026quot;;\r// 创建 axios 实例\rconst request = axios.create({\rbaseURL: \u0026quot;[/cmp/v1](https://api.example.com)\u0026quot;,\rtimeout: 2000 // 请求超时时间\r});\r// request 拦截器\rrequest.interceptors.request.use(\rconfit =\u0026gt; {\r// 设置 token，或者其他设置\rconfig.headers[\u0026quot;token\u0026quot;] = 'token_123';\rreturn config;\r},\rerr =\u0026gt; {\rreturn Promise.reject(err)\r},\r);\r// response 拦截器\rrequest.interceptors.response.use(\rresp =\u0026gt; resp.data,\rerror =\u0026gt; {\rif (error.response) {\rconst data = error.response.data;\rlet msg = data.desc || data.exception || '';\rswitch (error.response.status) {\rcase 401:\r// 提示：登录过期，跳转登录页面重新登录\rbreak;\rcase 403:\r// 提示：权限不足\rbreak;\rcase 404:\r// 提示：资源不存在\rbreak;\rdefault:\r// 提示：请求失败\rbreak;\r}\r}\rreturn Promise.reject(error);\r}\r);\r 封装各类型请求 这一步封装主要是为了统一 axios 中不同请求类型的参数要求。\n以 POST 和 GET 为例，封装之前\nconst payload = { ID: 12345 }\r// get 请求，params 属性值是携带的参数\raxios.get('/user', {\rparams: payload\r})\r// post 请求\raxios.post('/user', payload)\r 封装之后：\nconst payload = { ID: 12345 }\rGET('/user', payload)\rPOST('/user', payload)\r 封装之后，每种类型的请求方法都接受两个参数：url 和需要传递到服务端的数据 payload。\n这里我封装了 GET POST PUT DELETE 四种方法，分别对应 get post put delete 类型的请求：\nexport function GET (url, payload) {\rreturn request.get(url, {\rparams: payload\r});\r}\rexport function POST (url, payload) {\rreturn request.post(url, payload);\r}\rexport function PUT (url, payload) {\rreturn request.put(url, payload);\r}\rexport function DELETE (url, payload) {\rreturn request.delete(url, {\rdata: payload\r});\r}\r 使用方法：\n// 示例：\rimport { GET, POST, PUT, DELETE } from '@/utils/request.js'\rconst payload = { username: 'admin', password: '123456' }\rPOST('/login', payload)\r.then(resp =\u0026gt; {\r// 请求成功\r})\r.catch(err =\u0026gt; {\r// 请求失败\r})\r.finally {\r// 成功/失败都会执行这里代码\r}\r 其他 post 请求数据格式 默认情况下，axios 中 post 请求的 Content-Type 字段对应的值是 application/json ，此时是以 json 格式向服务端发送数据。\n如果想要以 FormData 形式发送数据，你可以这样解决\nimport axios from \u0026quot;axios\u0026quot;;\rimport qs from 'qs';\rconst data = { 'bar': 123 };\rconst options = {\rurl,\rmethod: 'POST',\rdata: qs.stringify(data),\rheaders: { 'content-type': 'application/x-www-form-urlencoded' },\r};\raxios(options);\r 那么前面对 POST 方法的封装也要进行修改：\nimport qs from 'qs';\rexport function POST (url, payload) {\rconst options = {\rurl,\rmethod: 'POST',\rdata: qs.stringify(data),\rheaders: { 'content-type': 'application/x-www-form-urlencoded' },\r};\rreturn request(options);\r}\r 挂载到 vue 原型上 import { GET, POST, PUT, DELETE } from '@/utils/request.js'\rVue.prototype.$http = {\rget: GET,\rpost: POST,\rput: PUT,\rdelete: DELETE\r}\r 挂载到原型上之后，就可以在任意的 vue 组件内通过 vue 实例调用请求：\nthis.$http.get('/user', { id: 123 })\r 完整代码 \r\r完整的 request.js 代码在此，请点击展开完整代码\r\r// request.js\rimport axios from \u0026quot;axios\u0026quot;;\r// 创建 axios 实例\rconst request = axios.create({\rbaseURL: \u0026quot;https://api.example.com\u0026quot;,\rtimeout: 2000, // 请求超时时间\r});\r// request 拦截器\rrequest.interceptors.request.use(\rconfit =\u0026gt; {\r// 设置 token，或者其他设置\rconfig.headers[\u0026quot;token\u0026quot;] = 'token_123';\rreturn config;\r},\rerr =\u0026gt; {\rreturn Promise.reject(err)\r},\r);\r// response 拦截器\rrequest.interceptors.response.use(\rresp =\u0026gt; resp.data,\rerror =\u0026gt; {\rif (error.response) {\rconst data = error.response.data;\rlet msg = data.desc || data.exception || '';\rswitch (error.response.status) {\rcase 401:\r// 提示：登录过期，跳转登录页面重新登录\rbreak;\rcase 403:\r// 提示：权限不足\rbreak;\rcase 404:\r// 提示：资源不存在\rbreak;\rdefault:\r// 提示：请求失败\rbreak;\r}\r}\rreturn Promise.reject(error);\r}\r);\rexport function GET (url, payload) {\rreturn request.get(url, {\rparams: payload\r});\r}\rexport function POST (url, payload) {\rreturn request.post(url, payload);\r}\rexport function PUT (url, payload) {\rreturn request.put(url, payload);\r}\rexport function PATCH (url, payload) {\rreturn request.patch(url, payload);\r}\rexport function DELETE (url, payload) {\rreturn request.delete(url, {\rparams: payload\r});\r}\r \r 本文完，感谢阅读。😜\n","date":1574408805,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1574408805,"objectID":"4dfff2fd9ae8ec0df91795d339407e0b","permalink":"/post/2019/2019-11-22-request-methods-with-axios/","publishdate":"2019-11-22T15:46:45+08:00","relpermalink":"/post/2019/2019-11-22-request-methods-with-axios/","section":"post","summary":"Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中\nAxios 有以下特点：\n 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造)  axios 的详细使用都可以在 https://github.com/axios/axios 中看到，本文主要将在项目实践中如何进一步封装 axios ，使得 axios 更符合实际需求。\n封装步骤 全局配置 全局配置是指配置 baseURL timeout 等选项。","tags":["ajax","axios"],"title":"Request Methods With Axios","type":"post"},{"authors":null,"categories":null,"content":" 根据 moment.js 得到一个单位时间或者时间段（如本周，上周，本月，上月，当前季度，上个季度）的开始结束时间\n  \rmomentjs 文档  主要利用以下几项 API：\n format(): 得到格式化的时间 startOf(): 得到一个单位时间的开始时间点，\r文档 endOf(): 得到一个单位时间的结束时间点 add(): 在指定时间点的基础上，加上一个时间段 subtract(): 在指定时间点的基础上，减去一个时间段 week(): 获取或设置一个时间对象的周数（第几周） month(): 获取或设置一个时间对象的月份 quarter(): 获取或设置一个时间对象的季度  天 // 获取当天开始结束时间\rfunction getCurrDays () {\rlet date = moment()\rlet start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r// 获取昨天的开始结束时间\rfunction getYesterday () {\rlet date = moment().subtract('days',1);\rlet start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r// 获取明天的开始结束时间\rfunction getTomorrow () {\rlet date = moment().add('days',1);\rlet start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r 周 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。\n// 本周\rfunction getCurrWeekDays () {\rlet date = moment()\rlet start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r// 上一周\rfunction getLastWeekDays () {\rlet date = moment().week(moment().week() - 1)\rlet start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r// 下一周\rfunction getNextWeekDays () {\rlet date = moment().week(moment().week() + 1)\rlet start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss')\rlet end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss')\rreturn [ start, end ]\r}\r 月 // 本月\rfunction getCurrMonthDays () {\rlet date = moment()\rlet start = date.startOf('month').format('YYYY-MM-DD')\rlet end = date.endOf('month').format('YYYY-MM-DD')\rreturn [ start, end ];\r}\r// 上个月\rfunction getLastMonthDays () {\rlet date = moment().month(moment().month() - 1)\rlet start = date.startOf('month').format('YYYY-MM-DD')\rlet end = date.endOf('month').format('YYYY-MM-DD')\rreturn [ start, end ];\r}\r// 下个月\rfunction getNextMonthDays () {\rlet date = moment().month(moment().month() + 1)\rlet start = date.startOf('month').format('YYYY-MM-DD')\rlet end = date.endOf('month').format('YYYY-MM-DD')\rreturn [ start, end ];\r}\r 季度 // 当前季度\rfunction getCurrQuarter () {\rlet date = moment()\rlet start = date.startOf('quarter').format('YYYY-MM-DD')\rlet end = date.endOf('quarter').format('YYYY-MM-DD')\rreturn [ start, end ];\r}\r// 上个季度\rfunction getLastQuarter () {\rlet date = moment().quarter(moment().quarter() - 1)\rlet start = date.startOf('quarter').format('YYYY-MM-DD')\rlet end = date.endOf('quarter').format('YYYY-MM-DD')\rreturn [ start, end ];\r}\r// 下个季度\rfunction getLastQuarter () {\rlet date = moment().quarter(moment().quarter() + 1)\r}\r DRY -  Don\u0026rsquo;t repeat yourself.\n 上面代码中可以看到有一个固定结构重复了好多次：\nfunction getX () {\rlet date = x\rlet start = date.startOf('时间单位类型').format('格式化')\rlet end = date.endOf('时间单位类型').format('格式化')\rreturn [ start, end ];\r}\r 所以我们可以专门封装一个函数，接收三个参数（时间，时间单位，格式化），返回开始和结束时间。\nfunction getDuringTime (date, type, format) {\rlet start = date.startOf(type).format(format)\rlet end = date.endOf(type).format(format)\rreturn [ start, end ];\r}\r 有了此工具函数，将上面代码汇总如下：\n/**\r* @param {date} date [momentjs 时间对象]\r* @param {String} type [单位时间类型]\r* @param {String} format [时间格式]\r* type 可以接收的值： year, month, quarter, week, isoWeek, day, date, hour, minute, second\r*/\rfunction getDuringTime (date=moment(), type='days', format='YYYY-MM-DD HH:mm:ss') {\rlet start = date.startOf(type).format(format)\rlet end = date.endOf(type).format(format)\rreturn [ start, end ];\r}\r// 获取当天开始结束时间\rfunction getCurrDays () {\rlet date = moment()\rreturn getDuringTime(date, 'days', 'YYYY-MM-DD')\r}\r// 获取昨天的开始结束时间\rfunction getYesterday () {\rlet date = moment().subtract('days',1)\rreturn getDuringTime(date, 'days', 'YYYY-MM-DD')\r}\r// 获取明天的开始结束时间\rfunction getTomorrow () {\rlet date = moment().add('days',1)\rreturn getDuringTime(date, 'days', 'YYYY-MM-DD')\r}\r// 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。\r// 本周\rfunction getCurrWeekDays () {\rlet date = moment()\rreturn getDuringTime(date, 'week', 'YYYY-MM-DD')\r}\r// 上一周\rfunction getLastWeekDays () {\rlet date = moment().week(moment().week() - 1)\rreturn getDuringTime(date, 'week', 'YYYY-MM-DD')\r}\r// 下一周\rfunction getNextWeekDays () {\rlet date = moment().week(moment().week() + 1)\rreturn getDuringTime(date, 'week', 'YYYY-MM-DD')\r}\r// 本月\rfunction getCurrMonthDays () {\rlet date = moment()\rreturn getDuringTime(date, 'month', 'YYYY-MM-DD')\r}\r// 上个月\rfunction getLastMonthDays () {\rlet date = moment().month(moment().month() - 1)\rreturn getDuringTime(date, 'month', 'YYYY-MM-DD')\r}\r// 下个月\rfunction getNextMonthDays () {\rlet date = moment().month(moment().month() + 1)\rreturn getDuringTime(date, 'month', 'YYYY-MM-DD')\r}\r// 当前季度\rfunction getCurrQuarter () {\rlet date = moment()\rreturn getDuringTime(date, 'quarter', 'YYYY-MM-DD')\r}\r// 上个季度\rfunction getLastQuarter () {\rlet date = moment().quarter(moment().quarter() - 1)\rreturn getDuringTime(date, 'quarter', 'YYYY-MM-DD')\r}\r// 下个季度\rfunction getLastQuarter () {\rlet date = moment().quarter(moment().quarter() + 1)\rreturn getDuringTime(date, 'quarter', 'YYYY-MM-DD')\r}\r  本文完，感谢阅读。😜\n","date":1574154271,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1574154271,"objectID":"e11152bbd4fe6f926aa7a6d044d27698","permalink":"/post/2019/2019-11-19-get-the-beginning-and-ending-in-a-unit-of-time-via-momentjs/","publishdate":"2019-11-19T17:04:31+08:00","relpermalink":"/post/2019/2019-11-19-get-the-beginning-and-ending-in-a-unit-of-time-via-momentjs/","section":"post","summary":"根据 moment.js 得到一个单位时间或者时间段（如本周，上周，本月，上月，当前季度，上个季度）的开始结束时间\n  \rmomentjs 文档  主要利用以下几项 API：\n format(): 得到格式化的时间 startOf(): 得到一个单位时间的开始时间点，\r文档 endOf(): 得到一个单位时间的结束时间点 add(): 在指定时间点的基础上，加上一个时间段 subtract(): 在指定时间点的基础上，减去一个时间段 week(): 获取或设置一个时间对象的周数（第几周） month(): 获取或设置一个时间对象的月份 quarter(): 获取或设置一个时间对象的季度  天 // 获取当天开始结束时间\rfunction getCurrDays () {\rlet date = moment()\rlet start = date.","tags":["momentjs"],"title":"Get the Beginning and Ending in a Unit of Time via Momentjs","type":"post"},{"authors":null,"categories":null,"content":" Ubuntu 基础设置，包含一些常用软件安装，配置文件修改等等。\n 这篇文章的意义在于，当你拿到一个新的 Ubuntu 系统之后，直接按照本文的步骤进行设置，就可以得到一个顺手的开发/部署环境。不再需要逐项搜索每个软件的安装步骤了。\n 设置国内软件镜像源 node git docker nginx oh-my-zsh alias vim  设置系统软件镜像源 配置系统源第一件事是修改镜像源，这样方便后续其他软件的安装。在国内可以选择阿里云的源。\n# 编辑源文件\rsudo vim /etc/apt/sources.list\r# 在VIM编辑器内替换默认源为阿里云\r:0,$ s/archive.ubuntu.com/mirrors.aliyun.com/\r# 保存源文件并退出\r:wq\r 包管理工具安装 先更新\nsudo apt update \u0026amp;\u0026amp; apt upgrade -y\r  \rLinux中apt与apt-get命令的区别与解释 \rlinux命令系列 sudo apt-get update和upgrade的区别  安装常用软件\n通常会有一些是默认安装的，比如 git vim wget curl vim，如果没有，用下面方式安装即可。\nsudo apt install zsh nginx tree -y\r oh-my-zsh 关于 zsh 和 oh-my-zsh 可以参考：\r终极 Shell——ZSH\n安装 脚本安装：\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\r 或者手动安装:\ngit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\rcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\r 安装完成之后退出当前会话重新打开一个终端窗口即可。\n插件 (1) autojump github 地址 autojump\n下载并执行\nwget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz\r./install.sh\r 最后把以下代码加入.zshrc:\n[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] \u0026amp;\u0026amp; . ~/.autojump/etc/profile.d/autojump.sh\r node(nvm) nvm github 地址：\rnvm-sh/nvm\n方法一：脚本安装 执行脚本\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash\r# 或者\rwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash\r 最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\u0026quot;$([ -z \u0026quot;${XDG_CONFIG_HOME-}\u0026quot; ] \u0026amp;\u0026amp; printf %s \u0026quot;${HOME}/.nvm\u0026quot; || printf %s \u0026quot;${XDG_CONFIG_HOME}/nvm\u0026quot;)\u0026quot;\r[ -s \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/nvm.sh\u0026quot; # This loads nvm\r 加载配置文件：\nsource ~/.bashrc\r 方法二：git 安装 将代码克隆到用户目录下：\ncd ~/\rgit clone https://github.com/nvm-sh/nvm.git .nvm\r 切换到最新版本\ncd ~/.nvm\rgit checkout v0.35.1\r 激活 nvm，在命令行执行：\n. nvm.sh\r 最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\u0026quot;$HOME/.nvm\u0026quot;\r[ -s \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/nvm.sh\u0026quot; # This loads nvm\r[ -s \u0026quot;$NVM_DIR/bash_completion\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/bash_completion\u0026quot; # This loads nvm bash_completion\r 完成之后，通过 nvm -v 查看版本来验证是否安装成功。\ndocker 安装 Docker curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; sudo sh get-docker.sh\r 安装 Compose sudo curl -L \u0026quot;https://github.com/docker/compose/releases/download/1.22.0/docke-compose-$(uname -s)-$(uname -m)\u0026quot; -o /usr/local/bin/docker-compose\r# 给Docker Compose 执行权限\rsudo chmod +x /usr/local/bin/docker-compose\r#查看Docker和Docker Compose的版本\rsudo docker version\rsudo docker-compose version\r 设置镜像源 执行下面命令进行设置\nps: 阿里云镜像源是个人注册阿里云账号之后分配的个人专属镜像源。\nsudo mkdir -p /etc/docker\rsudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-'EOF'\r{\r\u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://oojjt1xs.mirror.aliyuncs.com\u0026quot;]\r}\rEOF\rsudo systemctl daemon-reload\rsudo systemctl restart docker\r vim 配置 有些系统默认没有安装\n配置文件路径：\n 全局配置文件：/etc/vim/vimrc 当前用户配置文件：~/.vimrc  将下面内容粘贴到配置文件中：\n\u0026quot; 左单引号表示单行注释\r\u0026quot; 编码指定 UTF-8\rset fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936\rset termencoding=utf-8\rset encoding=utf-8\rset number \u0026quot; 显示行号\rset cursorline \u0026quot; 突出显示当前行\rset ruler \u0026quot; 打开状态栏标尺\r 设置别名(alias) 将所有的别名放在单独一个文件 .bash_aliases 中，这样更加方便管理，ubuntu 也推荐这种做法。\nif [ -f ~/.bash_aliases ]; then\r. ~/.bash_aliases\rfi\r 注意：等号两侧不能有空格!\n# 代替键盘上难以触及的 ~ 键\ralias home=\u0026quot;cd ~\u0026quot;\r# 同样也可以为一些深层却很常用的目录设置别名\r# 如：宝塔面包的 nginx 配置目录\ralias ng=\u0026quot;cd /www/server/panel/vhost/nginx\u0026quot;\r# 回退多级目录\ralias bk1=\u0026quot;cd ..\u0026quot;\ralias bk2=\u0026quot;cd ../..\u0026quot;\ralias bk3=\u0026quot;cd ../../..\u0026quot;\ralias bk4=\u0026quot;cd ../../../..\u0026quot;\ralias bk5=\u0026quot;cd ../../../../..\u0026quot;\r# ls 相关\ralias cls='clear'\ralias ll='ls -l'\ralias la='ls -a'\r# git 相关\ralias gs='git status'\ralias glog=\u0026quot;git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cr eset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit\u0026quot;\r# 解压\ralias -s gz='tar -xzvf'\ralias -s tgz='tar -xzvf'\ralias -s zip='unzip'\ralias -s bz2='tar -xjvf'\r# other\ralias vi='vim'\ralias grep=\u0026quot;grep --color=auto\u0026quot;\ralias tree=\u0026quot;tree -I '*svn|*node_module*'\u0026quot;\r  本文完，感谢阅读。😜\n","date":1573955371,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1573955371,"objectID":"d5734d32a69563d8a9c5286d92d67632","permalink":"/post/2019/2019-11-17-basic-setup-for-ubuntu/","publishdate":"2019-11-17T09:49:31+08:00","relpermalink":"/post/2019/2019-11-17-basic-setup-for-ubuntu/","section":"post","summary":"Ubuntu 基础设置，包含一些常用软件安装，配置文件修改等等。\n 这篇文章的意义在于，当你拿到一个新的 Ubuntu 系统之后，直接按照本文的步骤进行设置，就可以得到一个顺手的开发/部署环境。不再需要逐项搜索每个软件的安装步骤了。\n 设置国内软件镜像源 node git docker nginx oh-my-zsh alias vim  设置系统软件镜像源 配置系统源第一件事是修改镜像源，这样方便后续其他软件的安装。在国内可以选择阿里云的源。\n# 编辑源文件\rsudo vim /etc/apt/sources.list\r# 在VIM编辑器内替换默认源为阿里云\r:0,$ s/archive.ubuntu.com/mirrors.aliyun.com/\r# 保存源文件并退出\r:wq\r 包管理工具安装 先更新","tags":["ubuntu"],"title":"Basic Setup for Ubuntu","type":"post"},{"authors":null,"categories":null,"content":"安装 # ubuntu\rsudo apt install nginx -y\r 命令 nginx 命令    描述 命令 命令二     启动 sudo nginx sudo /usr/sbin/nginx   停止 sudo nginx -s stop sudo /usr/sbin/nginx -s stop   重启 sudo nginx -s restart sudo /usr/sbin/nginx -s restart   重载配置文件 sudo nginx -s reload sudo /usr/sbin/nginx -s reload    nginx 目录    描述 命令     nginx 安装目录 /usr/sbin/nginx   默认网站根目录 /usr/share/nginx/html   配置文件 /etc/nginx/nginx.conf     查找 nginx 安装目录的命令    描述 命令     查找 nginx 安装目录 which nginx   查找 nginx 配置文件 sudo find / -name nginx.conf   检测配置文件语法是否正确： sudo /usr/sbin/nginx -t    常见使用场景 (一) 静态网站 指定域名和对应的网站根目录位置，server_name 可以是域名、二级域名，也可以是 ip 地址。\nserver {\rlisten 80;\rserver_name demo.example.com;\rlocation / {\rroot /www/demo/;\rindex index.html index.htm;\r}\r}\r (二) 反向代理 场景：\n 解决跨域问题，利用 nginx 来访问其他域名下的接口 当 docker 服务的端口映射到宿主机上某个端口（如 8080）时，可以设置二级域名代理 8080 端口。  server {\rserver_name docker.example.com;\rlisten 80;\rlocation / {\rproxy_pass http://localhost:8000;\rproxy_set_header Host $host;\rproxy_set_header X-Forward-For $remote_addr;\r}\r}\r (三) 负载均衡 upstream backend {\rserver backend1.example.com weight=5;\rserver backend2.example.com:8080;\rserver unix:/tmp/backend3;\r}\rserver {\rlocation / {\rproxy_pass http://backend;\r}\r}\r 一些学习资源 \rNginx中文文档\n","date":1573874160,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1573874160,"objectID":"05cb283b5511c3e7d78779f5f62d04ba","permalink":"/post/2019/2019-11-16-basic-usage-of-nginx/","publishdate":"2019-11-16T11:16:00+08:00","relpermalink":"/post/2019/2019-11-16-basic-usage-of-nginx/","section":"post","summary":"安装 # ubuntu\rsudo apt install nginx -y\r 命令 nginx 命令    描述 命令 命令二     启动 sudo nginx sudo /usr/sbin/nginx   停止 sudo nginx -s stop sudo /usr/sbin/nginx -s stop   重启 sudo nginx -s restart sudo /usr/sbin/nginx -s restart   重载配置文件 sudo nginx -s reload sudo /usr/sbin/nginx -s reload    nginx 目录    描述 命令     nginx 安装目录 /usr/sbin/nginx   默认网站根目录 /usr/share/nginx/html   配置文件 /etc/nginx/nginx.","tags":["nginx"],"title":"Basic Usage of Nginx","type":"post"},{"authors":null,"categories":null,"content":"JavaScript 中的 this 总是指向一个对象，而具体指向哪个对象是在函数运行时的环境动态绑定的，而非函数被声明时的环境。\n但是 ES6 标准新增的箭头函数中的 this 却是由被声明的环境即上下文来确定的。\nthis 的指向大致分为下面 5 种：\n 作为对象的方法调用 作为普通函数调用 作为构造器调用 通过 call 和 apply 调用 箭头函数  情况一：作为普通函数调用 当函数作为普通函数或者匿名函数调用时，this 总是指向全局对象，在浏览器中这个全局对象是 window，在 nodejs 中全局对象是 global，这里讨论的是浏览器端，所有代码都可以在 chrome 开发者工具的 console 面板中执行。\nES5 规范提出了「严格模式」，在整个脚本文件第一行或者函数内第一行添加一条语句 'use strict'; 即可开启严格模式。\n如果启用「严格模式」，那么 this 就不再是指向全局对象，而是 undefined 。\n1) 普通函数：\nwindow.name = 'global name';\rfunction printName1 () {\rconsole.log(this === window); // true\rconsole.log(this.name); // \u0026quot;global object\u0026quot;\r}\rfunction printName2 () {\r\u0026quot;use strict\u0026quot;; // 启用严格模式\rconsole.log(this); // undefined\r}\rprintName1();\rprintName2();\r 2) 匿名函数：\n匿名函数自执行，这种形式封装公用库的时候最常见：\nwindow.name = 'global name';\r(function () {\rconsole.log(this === window); // true\rconsole.log(this.name); // \u0026quot;global object\u0026quot;\r})()\r 作为参数的匿名函数：\nwindow.name = 'global name';\rsetTimeout(function () {\rconsole.log(this === window); // true\rconsole.log(this.name); // \u0026quot;global object\u0026quot;\r}, 100);\r[1, 2, 3].forEach(function (item) {\rconsole.log(item, this.name)\r// 1 \u0026quot;global name\u0026quot;\r// 2 \u0026quot;global name\u0026quot;\r// 3 \u0026quot;global name\u0026quot;\r});\r 情况二：作为对象的方法调用 当函数作为对象当属性方法调用时，this 总指向这个对象。\nvar obj = {\rname: 'obj',\rprintName: function () {\rconsole.log(this === obj); // true\rconsole.log(this.name); // \u0026quot;obj\u0026quot;\r}\r}\robj.printName();\r 但是如果一个对象的属性方法又赋值给了其他变量，那么 this 将发生变化，其指向只有在函数执行那一刻才能确定。例如：\nvar obj = {\rname: 'obj',\rprintName: function () {\rconsole.log(this === obj); // true\rconsole.log(this.name); // \u0026quot;obj\u0026quot;\r}\r}\rvar myPrintName = obj.printName;\rwindow.name = 'global name';\rmyPrintName();\r// false\r// \u0026quot;global name\u0026quot;\r 当 myPrintName 执行时，就要按照普通函数来判断 this 指向了。\n再来一个例子：\nvar obj = {\rname: 'obj',\rprintName: function () {\rconsole.log(this === obj); // true\rconsole.log(this.name); // \u0026quot;obj\u0026quot;\r}\r}\rvar obj2 = {\rname: 'obj2',\r}\robj2.printName = obj.printName;\robj2.printName();\r// false\r// \u0026quot;obj2\u0026quot;\r 当 obj2.printName 执行时，printName 是作为 obj2 的属性方法来调用的，因此 this 指向 obj2 这个对象。\n所以说，JavaScript 中的 this 指向无法在定义时判断，只有在其执行时才能判断。\n情况三：作为构造器调用 在 JavaScript 中没有「类」的概念（直到 ES6 才有类的出现），而是把函数作为构造器，通过 new 操作符来生成实例。\n那么在构造函数中 this 就指向新生成的实例。\nvar MyClass = function () {\r// 给实例添加 name 属性\rthis.name = 'myclass'\rthis.printName = function () {\rreturn this.name\r}\r}\rvar obj = new MyClass()\robj.printName() // \u0026quot;myclass\u0026quot;\r 情况四：显式指定 this 前面的几种方法都是被动地根据代码执行时的环境来判断 this 具体指向哪里，那么有没有办法主动指定 this 指向呢。\n答案当然是有的，甚至它们的出场率还相当高。\n常见的显式指定 this 的方法主要是 call，apply 和 bind 来，在函数式编程中几乎离不开这三个方法。\n先定义如下变量：\nwindow.name = 'global name'\rfunction printName () {\rconsole.log(this.name)\r}\rvar obj1 = { name: 'obj1' }\rvar obj2 = { name: 'obj2' }\rvar obj3 = { name: 'obj3' }\r 默认情况 this 指向全局对象 window\nprintName() // \u0026quot;global name\u0026quot;\r 使用 call 来改变 this 指向：\nprintName.call(obj1) // \u0026quot;obj1\u0026quot;\r 使用 apply 来改变 this 指向：\nprintName.apply(obj2) // \u0026quot;obj2\u0026quot;\r 使用 bind 来改变 this 指向：\nvar printName2 = printName.bind(obj3)\rprintName2() // \u0026quot;obj3\u0026quot;\r 除此之外，还有一些函数也可以修改 this 指向，例如：forEach, map, filter, some, every 等。以 forEach 为例：\nvar obj = { name: 'zwc' }\rvar arr = [ 1, 2 ]\rarr.forEach(function (item, index) {\rconsole.log(item, this)\r})\r// 1 Window\r// 2 Window\rarr.forEach(function (item, index) {\rconsole.log(item, this)\r}, obj)\r// 1 {name: \u0026quot;zwc\u0026quot;}\r// 2 {name: \u0026quot;zwc\u0026quot;}\r forEach 第一个参数接收一个函数作为迭代器，用来处理数组中每一项元素，这个函数通常是一个匿名函数，函数内部的 this 指向全局对象。\nforEach 第二个参数可以接收一个对象，这个对象就是参数函数中的 this 指向。\n根据打印结果可以看到，在 forEach 的迭代器函数中的 this 已经指向了 obj 。\n情况五：ES6箭头函数 箭头函数简介 ES6 允许使用「箭头」（=\u0026gt;）定义函数。\nvar f = v =\u0026gt; v;\r// 等同于\rvar f = function (v) {\rreturn v;\r};\r 除了形式更简洁之外，箭头函数没有自己的 this，而是从自己作用域链的上一层继承 this。\n 箭头函数总是从自己作用域链的上一层继承 this。\n神马意思呢？我的理解就是箭头函数内部的 this 指向永远是箭头函数被定义时所在的作用域的 this，并且无法修改。\n 无法绑定 this 使用 call 来调用箭头函数时，第一个参数会被忽略，也就是说无法修改 this 指向。apply 和 bind 也是同样现象。\nvar printName = () =\u0026gt; {\rconsole.log(this === window); // true\r}\rvar obj = { name: 'obj' }\rprintName.call(obj);\r 例子一 来看一个例子，在不使用箭头函数的情况下，我们知道构造器函数内部 this 指向对象实例，而匿名函数的 this 是指向全局对象的，因此想要通过定时器打印对象实例的 age 属性，只能用一个变量 self 保存 this 的引用（即闭包）\nfunction Person(){\r// 构造器函数内部 this 指向对象实例\rthis.age = 0;\rvar self = this;\rsetInterval(function () {\r// 匿名函数中 this 指向全局对象\rconsole.log(self.age++)\r}, 1000);\r}\rvar p = new Person();\r 使用箭头函数之后，因为箭头函数的 this 继承自其被定义时所在环境的 this，在本例中这个 this 就是实例对象：\nfunction Person(){\r// 构造器函数内部 this 指向对象实例\rthis.age = 0;\rsetInterval(() =\u0026gt; {\r// 这里的 this 也指向构造函数的 this\rconsole.log(this.age++)\r}, 1000);\r}\rvar p = new Person();\r 例子二 再说一个更实用的例子：在 Vue.js 中使用箭头函数\nimport axios from 'axios';\rexport default {\rmethods: {\rfetch () {\raxios.get('/userinfo')\r.then(resp =\u0026gt; {\rthis.sayHi(); // this 指向 vue 实例\r})\r.catch(err =\u0026gt; {\rthis.sayHi(); // this 指向 vue 实例\r})\r},\rsayHi () {\rsetTimeout(() =\u0026gt; {\r// this 指向 vue 实例\r}, 1000);\r}\r}\r}\r 使用箭头函数之后，再也无需缓存 vue 实例，像是 var vm = this; 这种代码统统可以消灭掉，嗯，清爽！\n相关链接   \r严格模式 - MDN\n  \r箭头函数 - MDN\n  \r箭头函数 - ES6 入门\n  总结 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：\n 如果是该函数是一个普通函数或者匿名函数  在严格模式下的函数调用下，this 指向 undefined， 在非严格模式的函数调用中，this 指向全局对象，浏览器中全局对象是 window ，在 nodejs 中全局对象是 global   如果是该函数是一个构造函数，this 指针指向一个新的对象（实例） 如果是该函数是一个对象的方法，则它的this 指针指向这个对象 或者使用 call apply 等方法显式指定 this 的指向  在箭头函数中，则是根据箭头函数上下文决定其 this 指向，且无法修改 this 指向。\n 本文完，感谢阅读。😜\n","date":1569768540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569768540,"objectID":"2c571945a70bdd709c15dfa96bd7e23e","permalink":"/post/2019/2019-09-29-this-in-javascript/","publishdate":"2019-09-29T14:49:00Z","relpermalink":"/post/2019/2019-09-29-this-in-javascript/","section":"post","summary":"JavaScript 中的 this 总是指向一个对象，而具体指向哪个对象是在函数运行时的环境动态绑定的，而非函数被声明时的环境。\n但是 ES6 标准新增的箭头函数中的 this 却是由被声明的环境即上下文来确定的。\nthis 的指向大致分为下面 5 种：\n 作为对象的方法调用 作为普通函数调用 作为构造器调用 通过 call 和 apply 调用 箭头函数  情况一：作为普通函数调用 当函数作为普通函数或者匿名函数调用时，this 总是指向全局对象，在浏览器中这个全局对象是 window，在 nodejs 中全局对象是 global，这里讨论的是浏览器端，所有代码都可以在 chrome 开发者工具的 console 面板中执行。","tags":["js","this指向"],"title":"JavaScript 中 this 总结","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic \rAcademic | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click \rPDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? \rAsk\n\rDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Star\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1461715200,"objectID":"a7595a1aa9c5f04f5adcae9fa6e937f4","permalink":"/project/ibbpress/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/ibbpress/","section":"project","summary":"基于 Node.js (Nest.js) 、MySql 开发的博客系统","tags":["CMS"],"title":"IbbPress","type":"project"},{"authors":null,"categories":null,"content":"说明 写给自己看的 JavaScript 参考手册 What is this 此文档为本人复习 JavaScript 基础知识时所整理，文档内容来自以下网站以及个人的理解：\n \rJavaScript · MDN \rECMAScript 6 入门 \rJavaScript 高级程序设计  除去学习每个 API 的使用之外，还尽量考虑「不用eval的前提下用JS实现一次JS」。\nContributing 所有内容均为手打，且为个人见解，难免存在各种各样的问题。\n如果您对本站点有一些疑惑，或发现了一些问题，或有什么建议，欢迎在 issue board 中讨论。如果发现有重大问题可发 Email 至 1052642137@qq.com\n地址 文档地址：\rhttp://coolfe.fun/oh-my-js/\n备用地址：\rhttps://wencaizhang.github.io/oh-my-js/\nEnd Just for fun! 😝\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6fdeec05f41ea4e86d21815f0fc9bf42","permalink":"/doc/oh-my-js/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/doc/oh-my-js/readme/","section":"doc","summary":"说明 写给自己看的 JavaScript 参考手册 What is this 此文档为本人复习 JavaScript 基础知识时所整理，文档内容来自以下网站以及个人的理解：\n \rJavaScript · MDN \rECMAScript 6 入门 \rJavaScript 高级程序设计  除去学习每个 API 的使用之外，还尽量考虑「不用eval的前提下用JS实现一次JS」。\nContributing 所有内容均为手打，且为个人见解，难免存在各种各样的问题。\n如果您对本站点有一些疑惑，或发现了一些问题，或有什么建议，欢迎在 issue board 中讨论。如果发现有重大问题可发 Email 至 1052642137@qq.","tags":null,"title":"","type":"doc"}]